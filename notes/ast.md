### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient.
Here's the code that we write in [Trees.scala](/scalameta/trees/shared/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.scala.meta.internal.trees.Metadata.astClass() @new _root_.org.scalameta.adt.Metadata.leafClass() abstract trait If extends Term with _root_.scala.Product {
  @new _root_.scala.meta.internal.trees.Metadata.astField() def cond: Term;
  @new _root_.scala.meta.internal.trees.Metadata.astField() def thenp: Term;
  @new _root_.scala.meta.internal.trees.Metadata.astField() def elsep: Term;
  def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If
}
@new _root_.scala.meta.internal.trees.Metadata.astCompanion() @new _root_.org.scalameta.adt.Metadata.leafCompanion() object If extends scala.AnyRef {
  def <init>() = {
    super.<init>();
    ()
  };
  private object sharedClassifier extends _root_.scala.meta.classifiers.Classifier[_root_.scala.meta.Tree, If] {
    def <init>() = {
      super.<init>();
      ()
    };
    def apply(x: _root_.scala.meta.Tree): _root_.scala.Boolean = x.isInstanceOf[If]
  };
  implicit def ClassifierClass[T <: _root_.scala.meta.Tree]: _root_.scala.meta.classifiers.Classifier[T, If] = sharedClassifier.asInstanceOf[_root_.scala.meta.classifiers.Classifier[T, If]];
  def apply(cond: Term, thenp: Term, elsep: Term): If = {
    def internal(cond: Term, thenp: Term, elsep: Term): If = {
      _root_.scala.meta.internal.trees.CommonTyperMacros.hierarchyCheck[If];
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.nullCheck(elsep);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(cond);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(thenp);
      _root_.org.scalameta.data.DataTyperMacros.emptyCheck(elsep);
      val node = new TermIfImpl(null, null, null)(_root_.scala.meta.internal.trees.CommonTyperMacros.initParam(cond), _root_.scala.meta.internal.trees.CommonTyperMacros.initParam(thenp), _root_.scala.meta.internal.trees.CommonTyperMacros.initParam(elsep));
      _root_.scala.meta.internal.trees.CommonTyperMacros.storeField(node._cond, cond, "cond");
      _root_.scala.meta.internal.trees.CommonTyperMacros.storeField(node._thenp, thenp, "thenp");
      _root_.scala.meta.internal.trees.CommonTyperMacros.storeField(node._elsep, elsep, "elsep");
      node
    };
    internal(cond, thenp, elsep)
  };
  @new _root_.scala.inline() final def unapply(x: If): _root_.scala.Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  @new _root_.scala.meta.internal.trees.ast() private[meta] class Quasi extends If with _root_.scala.meta.internal.trees.Quasi with Term.Quasi {
    <paramaccessor> private[this] val rank: _root_.scala.Int = _;
    <paramaccessor> private[this] val tree: _root_.scala.meta.Tree = _;
    def <init>(rank: _root_.scala.Int, tree: _root_.scala.meta.Tree) = {
      super.<init>();
      ()
    };
    def pt: _root_.java.lang.Class[_$50] forSome {
      <synthetic> type _$50
    } = _root_.scala.meta.internal.trees.`package`.arrayClass(_root_.scala.Predef.classOf[If], this.rank);
    def cond: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def thenp: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def elsep: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def name: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def value: _root_.scala.Nothing = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = throw new _root_.scala.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position")
  };
  @new _root_.scala.SerialVersionUID(1L) final private[If] class TermIfImpl extends If {
    @new _root_.scala.transient() <paramaccessor> private[meta] val privatePrototype: If = _;
    <paramaccessor> private[meta] val privateParent: _root_.scala.meta.Tree = _;
    <paramaccessor> private[meta] val privateOrigin: _root_.scala.meta.internal.trees.Origin = _;
    <paramaccessor> var _cond: Term = _;
    <paramaccessor> var _thenp: Term = _;
    <paramaccessor> var _elsep: Term = _;
    def <init>(@new _root_.scala.transient() privatePrototype: If, privateParent: _root_.scala.meta.Tree, privateOrigin: _root_.scala.meta.internal.trees.Origin)(_cond: Term, _thenp: Term, _elsep: Term) = {
      super.<init>();
      ()
    };
    def cond: Term = {
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._cond, "cond");
      this._cond
    };
    def thenp: Term = {
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._thenp, "thenp");
      this._thenp
    };
    def elsep: Term = {
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._elsep, "elsep");
      this._elsep
    };
    private[meta] def privateCopy(prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = privateParent, destination: _root_.scala.Predef.String = null, origin: _root_.scala.meta.internal.trees.Origin = privateOrigin): Tree = {
      <empty>;
      new TermIfImpl(prototype.asInstanceOf[If], parent, origin)(_root_.scala.meta.internal.trees.CommonTyperMacros.initField(this._cond), _root_.scala.meta.internal.trees.CommonTyperMacros.initField(this._thenp), _root_.scala.meta.internal.trees.CommonTyperMacros.initField(this._elsep))
    };
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = If.apply(cond, thenp, elsep);
    def children: List[_root_.scala.meta.Tree] = _root_.scala.meta.internal.trees.CommonTyperMacros.children[If, _root_.scala.meta.Tree];
    override def productPrefix: _root_.scala.Predef.String = _root_.scala.meta.internal.trees.CommonTyperMacros.productPrefix[If];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.collection.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this);
    protected def writeReplace(): _root_.scala.AnyRef = {
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._cond, "cond");
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._thenp, "thenp");
      _root_.scala.meta.internal.trees.CommonTyperMacros.loadField(this._elsep, "elsep");
      this
    }
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract trait If extends AnyRef with scala.meta.Term with Product {
  @meta.internal.ast.Metadata.astField def cond: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def thenp: scala.meta.Term;
  @meta.internal.ast.Metadata.astField def elsep: scala.meta.Term;
  def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If;
  <synthetic> def copy$default$1: scala.meta.Term = this.cond;
  <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
  <synthetic> def copy$default$3: scala.meta.Term = this.elsep
};
@@<?> @@<?> object If extends scala.AnyRef with Serializable {
  def <init>(): scala.meta.Term.If.type = {
    If.super.<init>();
    ()
  };
  private object sharedClassifier extends AnyRef with scala.meta.classifiers.Classifier[scala.meta.Tree,scala.meta.Term.If] {
    def <init>(): scala.meta.Term.If.sharedClassifier.type = {
      sharedClassifier.super.<init>();
      ()
    };
    def apply(x: scala.meta.Tree): Boolean = x.isInstanceOf[scala.meta.Term.If]
  };
  implicit def ClassifierClass[T <: scala.meta.Tree]: scala.meta.classifiers.Classifier[T,scala.meta.Term.If] = If.this.sharedClassifier.asInstanceOf[scala.meta.classifiers.Classifier[T,scala.meta.Term.If]];
  def apply(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
    def internal(cond: scala.meta.Term, thenp: scala.meta.Term, elsep: scala.meta.Term): scala.meta.Term.If = {
      ((): Unit);
      (({
        val result$macro$309: Boolean = cond.!=(null);
        if (result$macro$309)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$308 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$308, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("cond", cond)))
      }: Unit): Unit);
      (({
        val result$macro$311: Boolean = thenp.!=(null);
        if (result$macro$311)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$310 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$310, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("thenp", thenp)))
      }: Unit): Unit);
      (({
        val result$macro$313: Boolean = elsep.!=(null);
        if (result$macro$313)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$312 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$312, scala.collection.immutable.Map.apply[String, scala.meta.Term](scala.Tuple2.apply[String, scala.meta.Term]("elsep", elsep)))
      }: Unit): Unit);
      ((): Unit);
      ((): Unit);
      ((): Unit);
      val node: scala.meta.Term.If.TermIfImpl = new If.this.TermIfImpl(null, null, null)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term));
      (node._cond_=(cond.privateCopy(cond, node, "cond", cond.privateCopy$default$4).asInstanceOf[scala.meta.Term]): Unit);
      (node._thenp_=(thenp.privateCopy(thenp, node, "thenp", thenp.privateCopy$default$4).asInstanceOf[scala.meta.Term]): Unit);
      (node._elsep_=(elsep.privateCopy(elsep, node, "elsep", elsep.privateCopy$default$4).asInstanceOf[scala.meta.Term]): Unit);
      node
    };
    internal(cond, thenp, elsep)
  };
  @inline final def unapply(x: scala.meta.Term.If): Option[(scala.meta.Term, scala.meta.Term, scala.meta.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.Term, scala.meta.Term, scala.meta.Term)](scala.Tuple3.apply[scala.meta.Term, scala.meta.Term, scala.meta.Term](x.cond, x.thenp, x.elsep));
  @meta.internal.ast.Metadata.astClass @org.scalameta.adt.Metadata.leafClass abstract private[meta] trait Quasi extends AnyRef with scala.meta.Term.If with scala.meta.internal.trees.Quasi with scala.meta.Term.Quasi with Product {
    @meta.internal.ast.Metadata.astField def rank: Int;
    @meta.internal.ast.Metadata.astField def tree: scala.meta.Tree
  };
  @@<?> @@<?> private[meta] object Quasi extends scala.AnyRef with Serializable {
    def <init>(): scala.meta.Term.If.Quasi.type = {
      Quasi.super.<init>();
      ()
    };
    private object sharedClassifier extends AnyRef with scala.meta.classifiers.Classifier[scala.meta.Tree,scala.meta.Term.If.Quasi] {
      def <init>(): scala.meta.Term.If.Quasi.sharedClassifier.type = {
        sharedClassifier.super.<init>();
        ()
      };
      def apply(x: scala.meta.Tree): Boolean = x.isInstanceOf[scala.meta.Term.If.Quasi]
    };
    implicit def ClassifierClass[T <: scala.meta.Tree]: scala.meta.classifiers.Classifier[T,scala.meta.Term.If.Quasi] = Quasi.this.sharedClassifier.asInstanceOf[scala.meta.classifiers.Classifier[T,scala.meta.Term.If.Quasi]];
    def apply(rank: Int, tree: scala.meta.Tree): scala.meta.Term.If.Quasi = {
      def internal(rank: Int, tree: scala.meta.Tree): scala.meta.Term.If.Quasi = {
        ((): Unit);
        ((): Unit);
        (({
          val result$macro$315: Boolean = tree.!=(null);
          if (result$macro$315)
            scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
          else
            scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("tree is equal to null"))
        } match {
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
          case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$314 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("tree.!=(null)", failures$macro$314, scala.collection.immutable.Map.apply[String, scala.meta.Tree](scala.Tuple2.apply[String, scala.meta.Tree]("tree", tree)))
        }: Unit): Unit);
        ((): Unit);
        ((): Unit);
        val node: scala.meta.Term.If.Quasi.TermIfQuasiImpl = new Quasi.this.TermIfQuasiImpl(null, null, null)((rank: Int), (null: scala.meta.Tree));
        ((): Unit);
        (node._tree_=(tree.privateCopy(tree, node, "tree", tree.privateCopy$default$4).asInstanceOf[scala.meta.Tree]): Unit);
        node
      };
      internal(rank, tree)
    };
    @inline final def unapply(x: scala.meta.Term.If.Quasi): Option[(Int, scala.meta.Tree)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(Int, scala.meta.Tree)](scala.Tuple2.apply[Int, scala.meta.Tree](x.rank, x.tree));
    @SerialVersionUID(value = 1L) final private[Quasi] class TermIfQuasiImpl extends AnyRef with scala.meta.Term.If.Quasi {
      @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If.Quasi = _;
      <stable> <accessor> <paramaccessor> private[meta] def privatePrototype: scala.meta.Term.If.Quasi = TermIfQuasiImpl.this.privatePrototype;
      <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> private[meta] def privateParent: scala.meta.Tree = TermIfQuasiImpl.this.privateParent;
      <paramaccessor> private[this] val privateOrigin: scala.meta.internal.trees.Origin = _;
      <stable> <accessor> <paramaccessor> private[meta] def privateOrigin: scala.meta.internal.trees.Origin = TermIfQuasiImpl.this.privateOrigin;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = TermIfQuasiImpl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = TermIfQuasiImpl.this._rank = x$1;
      <paramaccessor> private[this] var _tree: scala.meta.Tree = _;
      <accessor> <paramaccessor> def _tree: scala.meta.Tree = TermIfQuasiImpl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: scala.meta.Tree): Unit = TermIfQuasiImpl.this._tree = x$1;
      def <init>(privatePrototype: scala.meta.Term.If.Quasi, privateParent: scala.meta.Tree, privateOrigin: scala.meta.internal.trees.Origin)(_rank: Int, _tree: scala.meta.Tree): scala.meta.Term.If.Quasi.TermIfQuasiImpl = {
        TermIfQuasiImpl.super.<init>();
        ()
      };
      def pt: Class[_] = scala.meta.internal.trees.`package`.arrayClass(classOf[scala.meta.Term$$If], this.rank);
      def cond: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def name: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def value: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override <synthetic> def copy$default$1: scala.meta.Term = this.cond;
      override <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
      override <synthetic> def copy$default$3: scala.meta.Term = this.elsep;
      def rank: Int = {
        ((): Unit);
        this._rank
      };
      def tree: scala.meta.Tree = {
        (if (this._tree.==(null))
          {
            scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfQuasiImpl.tree");
            this._tree_=({
<artifact> val qual$95: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$409: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$410: scala.meta.Term.If.Quasi.TermIfQuasiImpl = this;
<artifact> val x$411: Null = null;
<artifact> val x$412: scala.meta.internal.trees.Origin = qual$95.privateCopy$default$4;
qual$95.privateCopy(x$409, x$410, x$411, x$412)
}.asInstanceOf[scala.meta.Tree])
          }
        else
          (): Unit);
        this._tree
      };
      private[meta] def privateCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = TermIfQuasiImpl.this.privateParent, destination: String = null, origin: scala.meta.internal.trees.Origin = TermIfQuasiImpl.this.privateOrigin): scala.meta.Tree = {
        new Quasi.this.TermIfQuasiImpl(prototype.asInstanceOf[scala.meta.Term.If.Quasi], parent, origin)((this._rank: Int), (null: scala.meta.Tree))
      };
      override <synthetic> def privateCopy$default$1: scala.meta.Tree = this;
      override <synthetic> def privateCopy$default$2: scala.meta.Tree = TermIfQuasiImpl.this.privateParent;
      override <synthetic> def privateCopy$default$3: String = null;
      override <synthetic> def privateCopy$default$4: scala.meta.internal.trees.Origin = TermIfQuasiImpl.this.privateOrigin;
      def children: scala.collection.immutable.List[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.Tree](this.tree): scala.collection.immutable.List[scala.meta.Tree]);
      override def productPrefix: String = ("Term.If.Quasi": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.rank
        case 1 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
      protected def writeReplace(): AnyRef = {
        ((): Unit);
        (if (this._tree.==(null))
          {
            scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfQuasiImpl.tree");
            this._tree_=({
<artifact> val qual$96: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$413: scala.meta.Tree = this.privatePrototype.tree;
<artifact> val x$414: scala.meta.Term.If.Quasi.TermIfQuasiImpl = this;
<artifact> val x$415: Null = null;
<artifact> val x$416: scala.meta.internal.trees.Origin = qual$96.privateCopy$default$4;
qual$96.privateCopy(x$413, x$414, x$415, x$416)
}.asInstanceOf[scala.meta.Tree])
          }
        else
          (): Unit);
        this
      };
      def become[T <: scala.meta.internal.trees.Quasi](implicit ev: scala.meta.internal.trees.AstInfo[T]): T = this match {
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)) => meta.this.Tree.XtensionOriginTree[T](ev.quasi(0, tree)).withOrigin(this.origin).asInstanceOf[T]
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (1, (nested @ If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)))) => meta.this.Tree.XtensionOriginTree[T](ev.quasi(1, nested.become[T](ev))).withOrigin(this.origin).asInstanceOf[T]
        case _ => throw new scala.`package`.Exception("complex ellipses are not supported yet")
      }
    };
    <synthetic> private def readResolve(): Object = If.this.Quasi
  };
  @SerialVersionUID(value = 1L) final private[If] class TermIfImpl extends AnyRef with scala.meta.Term.If {
    @transient <paramaccessor> private[this] val privatePrototype: scala.meta.Term.If = _;
    <stable> <accessor> <paramaccessor> private[meta] def privatePrototype: scala.meta.Term.If = TermIfImpl.this.privatePrototype;
    <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> private[meta] def privateParent: scala.meta.Tree = TermIfImpl.this.privateParent;
    <paramaccessor> private[this] val privateOrigin: scala.meta.internal.trees.Origin = _;
    <stable> <accessor> <paramaccessor> private[meta] def privateOrigin: scala.meta.internal.trees.Origin = TermIfImpl.this.privateOrigin;
    <paramaccessor> private[this] var _cond: scala.meta.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.Term = TermIfImpl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.Term = TermIfImpl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.Term = TermIfImpl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.Term): Unit = TermIfImpl.this._elsep = x$1;
    def <init>(privatePrototype: scala.meta.Term.If, privateParent: scala.meta.Tree, privateOrigin: scala.meta.internal.trees.Origin)(_cond: scala.meta.Term, _thenp: scala.meta.Term, _elsep: scala.meta.Term): scala.meta.Term.If.TermIfImpl = {
      TermIfImpl.super.<init>();
      ()
    };
    def cond: scala.meta.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.cond");
          this._cond_=({
<artifact> val qual$97: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$417: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$418: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$419: Null = null;
<artifact> val x$420: scala.meta.internal.trees.Origin = qual$97.privateCopy$default$4;
qual$97.privateCopy(x$417, x$418, x$419, x$420)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.thenp");
          this._thenp_=({
<artifact> val qual$98: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$421: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$422: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$423: Null = null;
<artifact> val x$424: scala.meta.internal.trees.Origin = qual$98.privateCopy$default$4;
qual$98.privateCopy(x$421, x$422, x$423, x$424)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.elsep");
          this._elsep_=({
<artifact> val qual$99: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$425: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$426: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$427: Null = null;
<artifact> val x$428: scala.meta.internal.trees.Origin = qual$99.privateCopy$default$4;
qual$99.privateCopy(x$425, x$426, x$427, x$428)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      this._elsep
    };
    private[meta] def privateCopy(prototype: scala.meta.Tree = this, parent: scala.meta.Tree = TermIfImpl.this.privateParent, destination: String = null, origin: scala.meta.internal.trees.Origin = TermIfImpl.this.privateOrigin): scala.meta.Tree = {
      new If.this.TermIfImpl(prototype.asInstanceOf[scala.meta.Term.If], parent, origin)((null: scala.meta.Term), (null: scala.meta.Term), (null: scala.meta.Term))
    };
    override <synthetic> def privateCopy$default$1: scala.meta.Tree = this;
    override <synthetic> def privateCopy$default$2: scala.meta.Tree = TermIfImpl.this.privateParent;
    override <synthetic> def privateCopy$default$3: String = null;
    override <synthetic> def privateCopy$default$4: scala.meta.internal.trees.Origin = TermIfImpl.this.privateOrigin;
    def copy(cond: scala.meta.Term = this.cond, thenp: scala.meta.Term = this.thenp, elsep: scala.meta.Term = this.elsep): scala.meta.Term.If = Term.this.If.apply(cond, thenp, elsep);
    override <synthetic> def copy$default$1: scala.meta.Term = this.cond;
    override <synthetic> def copy$default$2: scala.meta.Term = this.thenp;
    override <synthetic> def copy$default$3: scala.meta.Term = this.elsep;
    def children: scala.collection.immutable.List[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.Term](this.cond, this.thenp, this.elsep): scala.collection.immutable.List[scala.meta.Tree]);
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this);
    protected def writeReplace(): AnyRef = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.cond");
          this._cond_=({
<artifact> val qual$100: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$429: scala.meta.Term = this.privatePrototype.cond;
<artifact> val x$430: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$431: Null = null;
<artifact> val x$432: scala.meta.internal.trees.Origin = qual$100.privateCopy$default$4;
qual$100.privateCopy(x$429, x$430, x$431, x$432)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.thenp");
          this._thenp_=({
<artifact> val qual$101: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$433: scala.meta.Term = this.privatePrototype.thenp;
<artifact> val x$434: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$435: Null = null;
<artifact> val x$436: scala.meta.internal.trees.Origin = qual$101.privateCopy$default$4;
qual$101.privateCopy(x$433, x$434, x$435, x$436)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing TermIfImpl.elsep");
          this._elsep_=({
<artifact> val qual$102: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$437: scala.meta.Term = this.privatePrototype.elsep;
<artifact> val x$438: scala.meta.Term.If.TermIfImpl = this;
<artifact> val x$439: Null = null;
<artifact> val x$440: scala.meta.internal.trees.Origin = qual$102.privateCopy$default$4;
qual$102.privateCopy(x$437, x$438, x$439, x$440)
}.asInstanceOf[scala.meta.Term])
        }
      else
        (): Unit);
      this
    }
  };
  <synthetic> private def readResolve(): Object = Term.this.If
};
```
