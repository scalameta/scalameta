@import scala.meta.Readme._
@import Main._
@import scala.meta._

@sect("Scalameta", stableVersionBadge)

  @p
    Scalameta is a cross-platform, clean-room implementation of a
    metaprogramming toolkit for Scala, designed to be simple, robust and
    portable.  Scalameta's primary focus is to enable a new generation of
    syntactic and semantic @b{developer tools} for Scala.
    Please note that macros are no longer on the roadmap for Scalameta, see
    @lnk("scalamacros", "https://github.com/scalamacros/scalamacros") for more
    details.

  @sect{Features}
    @p
      @b
        High-fidelity parsing.
      Note how the abstract syntax trees in the printout below
      contain comprehensive information about formatting and comments.
      This is an exclusive feature of scalameta.

    @meta
      "x + y /* adds x and y */".parse[Term]
      "List[ Int ]".parse[Type]

    @p
      @b
        Tokens.
      Scalameta takes even the finest details of Scala code into account.
      We achieve this by attaching tokens, data structures representing atomic
      units of Scala syntax, to our abstract syntax trees. Note that the
      abstract syntax tree in the printout doesn't have the comment per se -
      it is stored in tokens instead.

    @meta
      val tree = "x + y /* adds x and y */".parse[Term].get
      tree.syntax
      tree.structure
      tree.tokens.structure

    @p
      @b
        Dialects.
      Scalameta is designed from the ground up to be platform-independent.
      This means that we understand different versions of the base language:
      Scala 2.10, Scala 2.11 and even Dotty. We also support Sbt build files
      to make sure we cover as much Scala code as possible.

    @meta
      import scala.meta.dialects.Sbt0137
      Sbt0137("""
        lazy val root = (project in file(".")).
        settings(name := "hello")
      """).parse[Source]
    @table
      @(cls := "pure-table")
      @(margin := "auto")
      @thead
        @tr
          @th
            Dialect
          @th
            Syntax
          @th
            Semantic
          @th
            Notes
      @tbody
        @def dialect(name: Dialect, syntax: String, semantic: String, notes: Frag*) = tr(
          td(name.toString),
          td(syntax),
          td(semantic),
          td(notes)
        )
        @dialect(dialects.Scala210, "Yes", "Yes*", "enabled with ", lnk("https://github.com/scalameta/sbthost"))
        @dialect(dialects.Sbt0137, "Yes", "Yes*", "enabled with ", lnk("https://github.com/scalameta/sbthost"))
        @dialect(dialects.Scala211, "Yes", "Yes", "Primary focus")
        @dialect(dialects.Scala212, "Yes", "Yes", "Primary focus")
        @dialect(dialects.Sbt1, "Yes", "No")
        @dialect(dialects.Dotty, "Partial", "No", "Missing support to parse enums")

    @p
      @b
        Quasiquotes.
      Quasiquotes have proven to be an amazing productivity booster in scala.reflect,
      so we implemented them in scalameta and now they are better than ever.
      Note how the precise types for @code("x") and @code("y")
      prevent the programmer from generating invalid code.
      Learn more about quasiquotes in
      @lnk("our documentation", "https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md").

    @meta
      val addition = q"x + y"
      val q"$x + $y" = addition

    @p
      @b
        Semantic API
      Semantic analysis of Scala programs has typically been tricky business, requiring
      intimate familiarity with scalac implementation details.
      The Scalameta Semantic API involves none of that. The Semantic API is powered by
      @lnk("Semantic DB", "http://scalameta.org/tutorial/#SemanticDB"), a simple
      @lnk("schema", "https://github.com/scalameta/scalameta/blob/master/langmeta/semanticdb/shared/src/main/protobuf/semanticdb.proto")
      for persisting semantic information extracted from a snapshot of the compiler after typer.
      By persisting semantic information instead of querying a live compiler instance,
      the same data can be used to power multiple applications running on
      different platforms.
      @table
        @(cls := "pure-table")
        @(margin := "auto")
        @thead
          @tr
            @th
              Feature
            @th
              Supported?
        @tbody
          @def feature(name: String, supported: String) = tr(td(name), td(supported))
          @feature("Reported message at position", "Yes")
          @feature("Symbol at position", "Yes")
          @feature("Type at symbol", "Yes")
          @feature("Type at position", "Planned")
          @feature("Type members", "Planned")
          @feature("Symbol at macro expansion", "Planned")
          @feature("Expanded macro", "Planned")
          @feature("implicit arguments at position", "Yes")
          @feature("implicit conversion at position", "Yes")
          @feature("Inferred .apply/.unapply at position", "Yes")
    @p
      @b
        Cross-platform.
      Scalameta compiles to JVM bytecode and JavaScript with @lnk("Scala.js",
      "https://www.scala-js.org/"). Support for Scala Native is
      @lnk("planned", "https://github.com/scalameta/scalameta/issues/772").

  @sect{Built with scalameta}
    @p
      Feel free to add your project to this list.
    @ul
      @li
         @lnk("Scalafmt", "http://scalameta.org/scalafmt/"): code formatter
      @li
         @lnk("Metadoc", "http://scalameta.org/metadoc/"): online code browser
         with "Jump to definition" and "See references".
      @li
        @lnk("Imclipitly", "https://github.com/ShaneDelmore/imclipitly"): Scala-Clippy advice generator for implicit enrichments
      @li
        @lnk("Stags", "https://github.com/pjrt/stags"): Scala tags generator
      @li
        @lnk("AST explorer", "https://astexplorer.net/#/gist/22cf8a3fcb2155c087ae94b4d194c1b6/d10c646ecfae4c69c919408aa3aaefb2deda2df7"): interactively explore Scalameta trees

  @sect{Releases}

    @p
      @b
        Train model.
      Every six weeks, we publish a release with the latest changes.
    @p
      @b
        Semantic versioning.
      With Scalameta v2.0 onwards, we follow
      @lnk("semantic versioning", "http://semver.org/") enforced with
      @lnk("MiMa", "https://github.com/typesafehub/migration-manager/").
      Binary breaking changes bump up the major version (e.g., 2.0.0 -> 3.0.0),
      backwards binary compatible improvements bump up the minor version (e.g.,
      2.0.0 -> 2.1.0) minor bug fixes bump up the patch version (e.g. 2.0.0 ->
      2.0.1).

    @p
      @b
        Milestone releases.
      Between major releases that break binary compatibility, we may cut
      milestone releases to test out work-in-progress binary breaking changes.

  @sect{Getting started}
    @p
      To get started with scalameta, add the following to your @code("build.sbt"):

    @hl.scala
      // Latest stable version
      libraryDependencies += "org.scalameta" %% "scalameta" % "@stableVersionString"

    @p
      Next, you'll need to add a single wildcard import to the files where you'll
      be using scalameta.

    @hl.scala
      import scala.meta._

  @sect{Tutorial}
    @p
      To learn more about practical aspects of using scalameta, take a look at
      our tutorial that is based on a workshop given by Ã“lafur Pall Geirsson at Scala World 2016:
      @lnk("http://scalameta.org/tutorial", "http://scalameta.org/tutorial").

  @sect{Roadmap}
    @p
      @b
        Refactoring.
      @lnk("Scalafix", "https://scalacenter.github.io/scalafix/") is a
      refactoring tool developed at the @lnk("Scala Center", "https://scala.epfl.ch/").
      Scalafix rewrites use the Scalameta Semantic and Syntactic APIs to do
      help automate migration between different library and compiler versions.

    @p
      @b
        Scala Native support.
      Slow startup time for JVM command-line tools is a big blocker for many
      exciting editor integrations, such as code formatting. Scala Native opens
      possiblities to implement command-line tools that run in milliseconds
      instead of seconds. We have validated that scalafmt can run on native,
      see @lnk("tweet", "https://twitter.com/olafurpg/status/857559907876433920"),
      we "just" need to get our tests ported to know it works as expected.
      See @lnk{https://github.com/scalameta/scalameta/issues/772}.

    @p
      @b
        Next generation of semantic tooling.
      As scalafix and metadoc show, it is possible to build
      cross-platform semantic developer tools using Scalameta. We are excited
      to see what other applications the community will build on top of Scalameta.

  @sect{Not on the roadmap}
    @p
      @b
        New-style macros.
      Efforts to support macros with Scalameta have been moved to 
      @lnk{https://github.com/scalamacros/scalamacros}.
      Scalameta's primary focus at the moment is to enable semantic tooling.

  @sect("Talks")
    @p
      @b
        Semantic Tooling at Twitter
      (ScalaDays Copenhagen 2017). This talk introduces semantic databases, the cornerstone of
      the scalameta semantic API, and explains how semantic databases can be used to integrate
      with Kythe, a language-agnostic ecosystem for developer tools. In this talk, we presented
      our vision of next-generation semantic tooling for the Scala ecosystem.

    @p
      Video: coming soon
      @lnk("https://www.youtube.com/watch?v=4yqDFsdKciA", "https://www.youtube.com/watch?v=4yqDFsdKciA")
      @br
      Slides:
      @lnk("http://scalameta.org/talks/2017-06-01-SemanticToolingAtTwitter.pdf", "http://scalameta.org/talks/2017-06-01-SemanticToolingAtTwitter.pdf")

    @p
      @b
        Metaprogramming 2.0
      (ScalaDays Berlin 2016). This talk explains the status of scalameta, demonstrates key features,
      presents the early adopters and publishes our plans for the future. In Berlin, we provided an extensive
      story of what's going to happen to compile-time metaprogramming in Scala,
      featuring a live demo of new-style ("inline") macros that support integration with IntelliJ IDEA.

    @p
      Video:
      @lnk("https://www.youtube.com/watch?v=IPnd_SZJ1nM", "https://www.youtube.com/watch?v=IPnd_SZJ1nM")
      @br
      Slides:
      @lnk("http://scalamacros.org/paperstalks/2016-06-17-Metaprogramming20.pdf", "http://scalamacros.org/paperstalks/2016-06-17-Metaprogramming20.pdf")

  @sect("Supporters")
    @p
      @raw
        <center>
          <a href="https://twitter.com/"><img width="112" height="90" src="images/twitter.png" /></a>
          &nbsp; &nbsp;
          <a href="https://www.jetbrains.com/"><img width="95" height="95" src="images/jetbrains.png" /></a>
          &nbsp; &nbsp;
          <a href="https://www.codacy.com/"><img width="105" height="105" src="images/codacy.png" /></a>
          &nbsp; &nbsp;
          <a href="https://scala.epfl.ch/"><img width="70" height="100" src="images/scala_center.png"/></a>
          &nbsp; &nbsp;
          <a href="https://www.evolutiongaming.com/"><img width="75" height="95" src="images/evolution_gaming.png"/></a>
        </center>

@copyrightBadge

@raw
  <a href="https://github.com/scalameta/scalameta"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

  <script>
    // NOTE: Disables the sidebar because we don't really have anything to show there yet.
    // Gonna re-enable it back by deleting this <script/> block once we have something interesting.
    (function() {
      controller = scalatex.scrollspy.Controller();
      controller.main = function(config) {}
    })()
  </script>
