### Internal structure of scala.meta ASTs

We use macro annotations to generate swaths of boilerplate that make our abstract syntax trees efficient and convenient.
Here's the code that we write in [Trees.scala](/scalameta/trees/src/main/scala/scala/meta/Trees.scala):

```
@ast class If(cond: Term, thenp: Term, elsep: Term) extends Term
```

Here's the code generated by the `@ast` macro annotation:

```
@new _root_.org.scalameta.ast.internal.astClass() @new _root_.org.scalameta.adt.Internal.leafClass() abstract trait If extends Term with _root_.scala.Product {
  @new _root_.org.scalameta.ast.internal.astField() def cond: Term;
  @new _root_.org.scalameta.ast.internal.astField() def thenp: Term;
  @new _root_.org.scalameta.ast.internal.astField() def elsep: Term;
  override type ThisType <: If
}
@new _root_.org.scalameta.ast.internal.astCompanion() @new _root_.org.scalameta.adt.Internal.leafCompanion() object If extends scala.AnyRef {
  def <init>() = {
    super.<init>();
    ()
  };
  def privateTag: _root_.scala.Int = _root_.org.scalameta.adt.Internal.calculateTag[If];
  def apply(cond: Term, thenp: Term, elsep: Term): If = {
    def internal(cond: Term, thenp: Term, elsep: Term): If = {
      _root_.org.scalameta.ast.internal.hierarchyCheck[If];
      _root_.org.scalameta.adt.Internal.nullCheck(cond);
      _root_.org.scalameta.adt.Internal.nullCheck(thenp);
      _root_.org.scalameta.adt.Internal.nullCheck(elsep);
      _root_.org.scalameta.adt.Internal.emptyCheck(cond);
      _root_.org.scalameta.adt.Internal.emptyCheck(thenp);
      _root_.org.scalameta.adt.Internal.emptyCheck(elsep);
      val node = new Impl(_root_.scala.meta.internal.flags.`package`.ZERO, null, null, null, null, null, null)(_root_.org.scalameta.ast.internal.initParam(cond), _root_.org.scalameta.ast.internal.initParam(thenp), _root_.org.scalameta.ast.internal.initParam(elsep));
      _root_.org.scalameta.ast.internal.storeField(node._cond, cond);
      _root_.org.scalameta.ast.internal.storeField(node._thenp, thenp);
      _root_.org.scalameta.ast.internal.storeField(node._elsep, elsep);
      node
    };
    internal(cond, thenp, elsep)
  };
  @new _root_.scala.inline() final def unapply(x: If): Option[scala.Tuple3[Term, Term, Term]] = if (x.$eq$eq(null))
    _root_.scala.None
  else
    _root_.scala.Some(scala.Tuple3(x.cond, x.thenp, x.elsep));
  import _root_.scala.language.experimental.{macros=>prettyPlease};
  import _root_.scala.language.implicitConversions;
  implicit <macro> def interfaceToApi(interface: If): Api = _root_.org.scalameta.ast.internal.Macros.interfaceToApi[If, Api];
  abstract trait Api extends If {
    def $init$() = {
      ()
    };
    def tokens: _root_.scala.meta.tokens.Tokens;
    private[meta] def env: _root_.scala.meta.internal.semantic.Environment;
    private[meta] def typing: _root_.scala.meta.internal.semantic.Typing;
    private[meta] def expansion: _root_.scala.meta.internal.semantic.Expansion;
    def copy(cond: Term = this.cond, thenp: Term = this.thenp, elsep: Term = this.elsep): If = If.apply(cond, thenp, elsep).withTokens(tokens = _root_.scala.meta.internal.tokens.TransformedTokens(this));
    protected def privateWithFlags(flags: _root_.scala.meta.internal.flags.`package`.Flags): If = {
      {
        if (flags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$eq$eq(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$amp$amp(this.expansion.$eq$eq(_root_.scala.meta.internal.semantic.Expansion.Zero)))
          throw new _root_.scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
        else
          ();
        if (flags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$eq$eq(_root_.scala.meta.internal.flags.`package`.TYPECHECKED).$amp$amp(this.typing.$eq$eq(_root_.scala.meta.internal.semantic.Typing.Zero)))
          throw new _root_.scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
        else
          ()
      };
      this.privateCopy(flags = flags)
    };
    def withTokens(tokens: _root_.scala.meta.tokens.Tokens): If = this.privateCopy(tokens = tokens);
    private[meta] def withEnv(env: _root_.scala.meta.internal.semantic.Environment): If = this.privateCopy(flags = this.privateFlags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED.unary_$tilde), env = env, denot = this.privateDenot, typing = _root_.scala.meta.internal.semantic.Typing.Zero, expansion = _root_.scala.meta.internal.semantic.Expansion.Zero);
    override private[meta] def withAttrs(typingLike: _root_.scala.meta.internal.semantic.TypingLike): If = {
      if (this.isInstanceOf[_root_.scala.meta.Term.Name].$bar$bar(this.isInstanceOf[_root_.scala.meta.Ctor.Name]))
        throw new UnsupportedOperationException("need to simultaneously set both denotation and typing for a ".$plus(this.productPrefix))
      else
        ();
      if (isUnattributed.unary_$bang)
        throw new UnsupportedOperationException("can only call withAttrs on unattributed trees; if necessary, call .copy() to unattribute and then do .withAttrs(...)".$plus("\n").$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
      else
        ();
      val typing = typingLike.typing;
      this.privateCopy(flags = this.privateFlags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED.unary_$tilde), env = _root_.scala.meta.internal.semantic.Environment.Zero, denot = this.privateDenot, typing = typing, expansion = _root_.scala.meta.internal.semantic.Expansion.Identity)
    };
    private[meta] def withExpansion(expansionLike: _root_.scala.meta.internal.semantic.ExpansionLike): If = {
      if (isPartiallyAttributed.unary_$bang)
        throw new UnsupportedOperationException(if (isUnattributed)
  "can only call withExpansion on partially attributed trees, call .withAttrs first and only then .withExpansion(...)"
else
  "can only call withExpansion on partially attributed trees, if necessary, call .copy() to unattribute, then .withAttrs(...) and only then .withExpansion(...)".$plus("\n").$plus(_root_.scala.meta.internal.prettyprinters.Attributes.attributesTree[_root_.scala.meta.Tree](_root_.scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, _root_.scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString))
      else
        ();
      val expansion = expansionLike.expansion;
      this.privateCopy(flags = this.privateFlags.$amp(_root_.scala.meta.internal.flags.`package`.TYPECHECKED.unary_$tilde), env = this.privateEnv, denot = this.privateDenot, typing = this.privateTyping, expansion = expansion)
    };
    override type ThisType = If;
    override def privateTag: _root_.scala.Int = If.privateTag;
    override def productPrefix: _root_.scala.Predef.String = _root_.org.scalameta.ast.internal.productPrefix[ThisType];
    override def productArity: _root_.scala.Int = 3;
    override def productElement(n: _root_.scala.Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new _root_.scala.IndexOutOfBoundsException(n.toString)
    };
    override def productIterator: _root_.scala.Iterator[_root_.scala.Any] = _root_.scala.runtime.ScalaRunTime.typedProductIterator(this)
  };
  @new _root_.scala.SerialVersionUID(1L) final private[If] class Impl extends Api {
    <paramaccessor> protected val privateFlags: _root_.scala.meta.internal.flags.`package`.Flags = _;
    @new _root_.scala.transient() <paramaccessor> protected val privatePrototype: If = _;
    <paramaccessor> protected val privateParent: _root_.scala.meta.Tree = _;
    @new _root_.scala.transient() <paramaccessor> protected var privateTokens: _root_.scala.meta.tokens.Tokens = _;
    <paramaccessor> protected val privateEnv: _root_.scala.meta.internal.semantic.Environment = _;
    <paramaccessor> protected val privateTyping: _root_.scala.meta.internal.semantic.Typing = _;
    <paramaccessor> protected val privateExpansion: _root_.scala.meta.internal.semantic.Expansion = _;
    <paramaccessor> var _cond: Term = _;
    <paramaccessor> var _thenp: Term = _;
    <paramaccessor> var _elsep: Term = _;
    def <init>(privateFlags: _root_.scala.meta.internal.flags.`package`.Flags, @new _root_.scala.transient() privatePrototype: If, privateParent: _root_.scala.meta.Tree, @new _root_.scala.transient() privateTokens: _root_.scala.meta.tokens.Tokens, privateEnv: _root_.scala.meta.internal.semantic.Environment, privateTyping: _root_.scala.meta.internal.semantic.Typing, privateExpansion: _root_.scala.meta.internal.semantic.Expansion)(_cond: Term, _thenp: Term, _elsep: Term) = {
      super.<init>();
      ()
    };
    def parent: _root_.scala.Option[_root_.scala.meta.Tree] = if (privateParent.$bang$eq(null))
      _root_.scala.Some(privateParent)
    else
      _root_.scala.None;
    def children: Seq[_root_.scala.meta.Tree] = _root_.org.scalameta.ast.internal.children[ThisType, _root_.scala.meta.Tree];
    def tokens: _root_.scala.meta.tokens.Tokens = {
      privateTokens = privateTokens match {
        case null => _root_.scala.meta.internal.prettyprinters.inferTokens(this, None)
        case _root_.scala.meta.internal.tokens.TransformedTokens((proto @ _)) => _root_.scala.meta.internal.prettyprinters.inferTokens(this, Some(proto))
        case (other @ _) => other
      };
      privateTokens
    };
    private[meta] def env: _root_.scala.meta.internal.semantic.Environment = if (privateEnv.$bang$eq(null))
      privateEnv
    else
      _root_.scala.meta.internal.semantic.Environment.Zero;
    protected def privateDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    private[meta] def typing: _root_.scala.meta.internal.semantic.Typing = if (privateTyping.$bang$eq(null))
      privateTyping
    else
      _root_.scala.meta.internal.semantic.Typing.Zero;
    private[meta] def expansion: _root_.scala.meta.internal.semantic.Expansion = if (privateExpansion.$bang$eq(null))
      privateExpansion
    else
      _root_.scala.meta.internal.semantic.Expansion.Zero;
    def cond: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      this._cond
    };
    def thenp: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      this._thenp
    };
    def elsep: Term = {
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this._elsep
    };
    private[meta] def privateCopy(flags: _root_.scala.meta.internal.flags.`package`.Flags = privateFlags, prototype: _root_.scala.meta.Tree = this, parent: _root_.scala.meta.Tree = privateParent, tokens: _root_.scala.meta.tokens.Tokens = privateTokens, env: _root_.scala.meta.internal.semantic.Environment = privateEnv, denot: _root_.scala.meta.internal.semantic.Denotation = privateDenot, typing: _root_.scala.meta.internal.semantic.Typing = privateTyping, expansion: _root_.scala.meta.internal.semantic.Expansion = privateExpansion): ThisType = new Impl(flags, prototype.asInstanceOf[ThisType], parent, tokens, env, typing, expansion)(_root_.org.scalameta.ast.internal.initField(this._cond), _root_.org.scalameta.ast.internal.initField(this._thenp), _root_.org.scalameta.ast.internal.initField(this._elsep));
    protected def writeReplace(): _root_.scala.AnyRef = {
      _root_.org.scalameta.ast.internal.loadField(this._cond);
      _root_.org.scalameta.ast.internal.loadField(this._thenp);
      _root_.org.scalameta.ast.internal.loadField(this._elsep);
      this
    }
  };
  @new _root_.org.scalameta.ast.ast() private[meta] class Quasi extends If with _root_.scala.meta.internal.ast.Quasi with Term.Quasi {
    <paramaccessor> private[this] val rank: _root_.scala.Int = _;
    <paramaccessor> private[this] val tree: _root_.scala.Any = _;
    def <init>(rank: _root_.scala.Int, tree: _root_.scala.Any) = {
      super.<init>();
      ()
    };
    override private[meta] def env: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def privateEnv: _root_.scala.meta.internal.semantic.Environment = null;
    override protected def privateDenot: _root_.scala.meta.internal.semantic.Denotation = null;
    override private[meta] def typing: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def privateTyping: _root_.scala.meta.internal.semantic.Typing = null;
    override private[meta] def expansion: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override protected def privateExpansion: _root_.scala.meta.internal.semantic.Expansion = null;
    override def cond: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def thenp: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override def elsep: _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override private[meta] def withEnv(env: _root_.scala.meta.internal.semantic.Environment): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override private[meta] def withAttrs(typingLike: _root_.scala.meta.internal.semantic.TypingLike): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    override private[meta] def withExpansion(expansionLike: _root_.scala.meta.internal.semantic.ExpansionLike): _root_.scala.Nothing = throw new _root_.scala.`package`.UnsupportedOperationException(if (this.rank.$eq$eq(0))
      "unsupported unquoting position"
    else
      "unsupported splicing position");
    def pt: _root_.java.lang.Class[_$63] forSome {
      <synthetic> type _$63
    } = _root_.org.scalameta.runtime.arrayClass(_root_.scala.Predef.classOf[If], this.rank)
  }
}
```

Here's the same code after typechecking with helper def macros expanded:

```
@org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract trait If extends AnyRef with scala.meta.internal.ast.Term with Product {
  @org.scalameta.ast.internal.astField def cond: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def thenp: scala.meta.internal.ast.Term;
  @org.scalameta.ast.internal.astField def elsep: scala.meta.internal.ast.Term;
  override type ThisType <: scala.meta.internal.ast.Term.If
};
@@<?> @@<?> object If extends scala.AnyRef with Serializable {
  def <init>(): scala.meta.internal.ast.Term.If.type = {
    If.super.<init>();
    ()
  };
  def privateTag: Int = 88;
  def apply(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If = {
    def internal(cond: scala.meta.internal.ast.Term, thenp: scala.meta.internal.ast.Term, elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If = {
      ((): Unit);
      ({
        val result$macro$198: Boolean = cond.!=(null);
        if (result$macro$198)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("cond is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$197 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("cond.!=(null)", failures$macro$197, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("cond", cond)))
      }: Unit);
      ({
        val result$macro$200: Boolean = thenp.!=(null);
        if (result$macro$200)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("thenp is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$199 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("thenp.!=(null)", failures$macro$199, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("thenp", thenp)))
      }: Unit);
      ({
        val result$macro$202: Boolean = elsep.!=(null);
        if (result$macro$202)
          scala.Tuple2.apply[Boolean, collection.immutable.Nil.type](true, scala.collection.immutable.Nil)
        else
          scala.Tuple2.apply[Boolean, List[String]](false, scala.collection.immutable.List.apply[String]("elsep is equal to null"))
      } match {
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(true, _) => ()
        case (_1: Boolean, _2: List[String])(Boolean, List[String])(false, (failures$macro$201 @ _)) => org.scalameta.invariants.InvariantFailedException.raise("elsep.!=(null)", failures$macro$201, scala.collection.immutable.Map.apply[String, scala.meta.internal.ast.Term](scala.Tuple2.apply[String, scala.meta.internal.ast.Term]("elsep", elsep)))
      }: Unit);
      ();
      ();
      ();
      val node: scala.meta.internal.ast.Term.If.Impl = new If.this.Impl(scala.meta.internal.flags.`package`.ZERO, null, null, null, null, null, null)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
      (node._cond_=({
        <artifact> val x$1930: scala.meta.internal.ast.Term = cond;
        <artifact> val x$1931: scala.meta.internal.ast.Term.If.Impl = node;
        <artifact> val x$1932: meta.internal.flags.Flags = cond.privateCopy$default$1;
        <artifact> val x$1933: scala.meta.tokens.Tokens = cond.privateCopy$default$4;
        <artifact> val x$1934: scala.meta.internal.semantic.Environment = cond.privateCopy$default$5;
        <artifact> val x$1935: scala.meta.internal.semantic.Denotation = cond.privateCopy$default$6;
        <artifact> val x$1936: scala.meta.internal.semantic.Typing = cond.privateCopy$default$7;
        <artifact> val x$1937: scala.meta.internal.semantic.Expansion = cond.privateCopy$default$8;
        cond.privateCopy(x$1932, x$1930, x$1931, x$1933, x$1934, x$1935, x$1936, x$1937)
      }): Unit);
      (node._thenp_=({
        <artifact> val x$1938: scala.meta.internal.ast.Term = thenp;
        <artifact> val x$1939: scala.meta.internal.ast.Term.If.Impl = node;
        <artifact> val x$1940: meta.internal.flags.Flags = thenp.privateCopy$default$1;
        <artifact> val x$1941: scala.meta.tokens.Tokens = thenp.privateCopy$default$4;
        <artifact> val x$1942: scala.meta.internal.semantic.Environment = thenp.privateCopy$default$5;
        <artifact> val x$1943: scala.meta.internal.semantic.Denotation = thenp.privateCopy$default$6;
        <artifact> val x$1944: scala.meta.internal.semantic.Typing = thenp.privateCopy$default$7;
        <artifact> val x$1945: scala.meta.internal.semantic.Expansion = thenp.privateCopy$default$8;
        thenp.privateCopy(x$1940, x$1938, x$1939, x$1941, x$1942, x$1943, x$1944, x$1945)
      }): Unit);
      (node._elsep_=({
        <artifact> val x$1946: scala.meta.internal.ast.Term = elsep;
        <artifact> val x$1947: scala.meta.internal.ast.Term.If.Impl = node;
        <artifact> val x$1948: meta.internal.flags.Flags = elsep.privateCopy$default$1;
        <artifact> val x$1949: scala.meta.tokens.Tokens = elsep.privateCopy$default$4;
        <artifact> val x$1950: scala.meta.internal.semantic.Environment = elsep.privateCopy$default$5;
        <artifact> val x$1951: scala.meta.internal.semantic.Denotation = elsep.privateCopy$default$6;
        <artifact> val x$1952: scala.meta.internal.semantic.Typing = elsep.privateCopy$default$7;
        <artifact> val x$1953: scala.meta.internal.semantic.Expansion = elsep.privateCopy$default$8;
        elsep.privateCopy(x$1948, x$1946, x$1947, x$1949, x$1950, x$1951, x$1952, x$1953)
      }): Unit);
      node
    };
    internal(cond, thenp, elsep)
  };
  @inline final def unapply(x: scala.meta.internal.ast.Term.If): Option[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)] = if (x.==(null))
    scala.None
  else
    scala.Some.apply[(scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term)](scala.Tuple3.apply[scala.meta.internal.ast.Term, scala.meta.internal.ast.Term, scala.meta.internal.ast.Term](x.cond, x.thenp, x.elsep));
  import scala.language.experimental.{macros=>prettyPlease};
  import scala.language.implicitConversions;
  @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If): scala.meta.internal.ast.Term.If.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If, scala.meta.internal.ast.Term.If.Api];
  abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If {
    def /*Api*/$init$(): Unit = {
      ()
    };
    def tokens: scala.meta.tokens.Tokens;
    private[meta] def env: scala.meta.internal.semantic.Environment;
    private[meta] def typing: scala.meta.internal.semantic.Typing;
    private[meta] def expansion: scala.meta.internal.semantic.Expansion;
    def copy(cond: scala.meta.internal.ast.Term = this.cond, thenp: scala.meta.internal.ast.Term = this.thenp, elsep: scala.meta.internal.ast.Term = this.elsep): scala.meta.internal.ast.Term.If = Term.this.If.apply(cond, thenp, elsep).withTokens(scala.meta.internal.tokens.TransformedTokens.apply(this));
    <synthetic> def copy$default$1: scala.meta.internal.ast.Term = this.cond;
    <synthetic> def copy$default$2: scala.meta.internal.ast.Term = this.thenp;
    <synthetic> def copy$default$3: scala.meta.internal.ast.Term = this.elsep;
    protected def privateWithFlags(flags: meta.internal.flags.Flags): scala.meta.internal.ast.Term.If = {
      {
        if (flags.&(scala.meta.internal.flags.`package`.TYPECHECKED).==(scala.meta.internal.flags.`package`.TYPECHECKED).&&(this.expansion.==(scala.meta.internal.semantic.Expansion.Zero)))
          throw new scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
        else
          ();
        if (flags.&(scala.meta.internal.flags.`package`.TYPECHECKED).==(scala.meta.internal.flags.`package`.TYPECHECKED).&&(this.typing.==(scala.meta.internal.semantic.Typing.Zero)))
          throw new scala.`package`.UnsupportedOperationException("failed to enable TYPECHECKED for ".+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
        else
          ()
      };
      this.privateCopy(flags, this.privateCopy$default$2, this.privateCopy$default$3, this.privateCopy$default$4, this.privateCopy$default$5, this.privateCopy$default$6, this.privateCopy$default$7, this.privateCopy$default$8)
    };
    def withTokens(tokens: scala.meta.tokens.Tokens): scala.meta.internal.ast.Term.If = {
      <artifact> val x$1954: scala.meta.tokens.Tokens = tokens;
      <artifact> val x$1955: meta.internal.flags.Flags = this.privateCopy$default$1;
      <artifact> val x$1956: scala.meta.Tree = this.privateCopy$default$2;
      <artifact> val x$1957: scala.meta.Tree = this.privateCopy$default$3;
      <artifact> val x$1958: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
      <artifact> val x$1959: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
      <artifact> val x$1960: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
      <artifact> val x$1961: scala.meta.internal.semantic.Expansion = this.privateCopy$default$8;
      this.privateCopy(x$1955, x$1956, x$1957, x$1954, x$1958, x$1959, x$1960, x$1961)
    };
    private[meta] def withEnv(env: scala.meta.internal.semantic.Environment): scala.meta.internal.ast.Term.If = {
      <artifact> val x$1962: Int = this.privateFlags.&(scala.meta.internal.flags.`package`.TYPECHECKED.unary_~);
      <artifact> val x$1963: scala.meta.internal.semantic.Environment = env;
      <artifact> val x$1964: scala.meta.internal.semantic.Denotation = this.privateDenot;
      <artifact> val x$1965: meta.internal.semantic.Typing.Zero.type = scala.meta.internal.semantic.Typing.Zero;
      <artifact> val x$1966: meta.internal.semantic.Expansion.Zero.type = scala.meta.internal.semantic.Expansion.Zero;
      <artifact> val x$1967: scala.meta.Tree = this.privateCopy$default$2;
      <artifact> val x$1968: scala.meta.Tree = this.privateCopy$default$3;
      <artifact> val x$1969: scala.meta.tokens.Tokens = this.privateCopy$default$4;
      this.privateCopy(x$1962, x$1967, x$1968, x$1969, x$1963, x$1964, x$1965, x$1966)
    };
    override private[meta] def withAttrs(typingLike: meta.internal.semantic.TypingLike): scala.meta.internal.ast.Term.If = {
      if (this.isInstanceOf[meta.Term.Name].||(this.isInstanceOf[meta.Ctor.Name]))
        throw new scala.`package`.UnsupportedOperationException("need to simultaneously set both denotation and typing for a ".+(this.productPrefix))
      else
        ();
      if (Api.this.isUnattributed.unary_!)
        throw new scala.`package`.UnsupportedOperationException("can only call withAttrs on unattributed trees; if necessary, call .copy() to unattribute and then do .withAttrs(...)\n".+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
      else
        ();
      val typing: scala.meta.internal.semantic.Typing = typingLike.typing;
      {
        <artifact> val x$1970: Int = this.privateFlags.&(scala.meta.internal.flags.`package`.TYPECHECKED.unary_~);
        <artifact> val x$1971: meta.internal.semantic.Environment.Zero.type = scala.meta.internal.semantic.Environment.Zero;
        <artifact> val x$1972: scala.meta.internal.semantic.Denotation = this.privateDenot;
        <artifact> val x$1973: scala.meta.internal.semantic.Typing = typing;
        <artifact> val x$1974: meta.internal.semantic.Expansion.Identity.type = scala.meta.internal.semantic.Expansion.Identity;
        <artifact> val x$1975: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$1976: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$1977: scala.meta.tokens.Tokens = this.privateCopy$default$4;
        this.privateCopy(x$1970, x$1975, x$1976, x$1977, x$1971, x$1972, x$1973, x$1974)
      }
    };
    private[meta] def withExpansion(expansionLike: meta.internal.semantic.ExpansionLike): scala.meta.internal.ast.Term.If = {
      if (Api.this.isPartiallyAttributed.unary_!)
        throw new scala.`package`.UnsupportedOperationException(if (Api.this.isUnattributed)
"can only call withExpansion on partially attributed trees, call .withAttrs first and only then .withExpansion(...)"
else
"can only call withExpansion on partially attributed trees, if necessary, call .copy() to unattribute, then .withAttrs(...) and only then .withExpansion(...)".+("\n").+(scala.meta.internal.prettyprinters.Attributes.attributesTree[scala.meta.Tree](scala.meta.internal.prettyprinters.Attributes.Recursion.Deep, scala.meta.internal.prettyprinters.Attributes.Force.Never).apply(this).toString()))
      else
        ();
      val expansion: scala.meta.internal.semantic.Expansion = expansionLike.expansion;
      {
        <artifact> val x$1978: Int = this.privateFlags.&(scala.meta.internal.flags.`package`.TYPECHECKED.unary_~);
        <artifact> val x$1979: scala.meta.internal.semantic.Environment = this.privateEnv;
        <artifact> val x$1980: scala.meta.internal.semantic.Denotation = this.privateDenot;
        <artifact> val x$1981: scala.meta.internal.semantic.Typing = this.privateTyping;
        <artifact> val x$1982: scala.meta.internal.semantic.Expansion = expansion;
        <artifact> val x$1983: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$1984: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$1985: scala.meta.tokens.Tokens = this.privateCopy$default$4;
        this.privateCopy(x$1978, x$1983, x$1984, x$1985, x$1979, x$1980, x$1981, x$1982)
      }
    };
    override type ThisType = scala.meta.internal.ast.Term.If;
    override def privateTag: Int = Term.this.If.privateTag;
    override def productPrefix: String = ("Term.If": String);
    override def productArity: Int = 3;
    override def productElement(n: Int): Any = n match {
      case 0 => this.cond
      case 1 => this.thenp
      case 2 => this.elsep
      case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
    };
    override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
  };
  @SerialVersionUID(value = 1L) final private[If] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Api {
    <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
    <stable> <accessor> <paramaccessor> protected def privateFlags: meta.internal.flags.Flags = Impl.this.privateFlags;
    @transient <paramaccessor> private[this] val privatePrototype: scala.meta.internal.ast.Term.If = _;
    <stable> <accessor> <paramaccessor> protected def privatePrototype: scala.meta.internal.ast.Term.If = Impl.this.privatePrototype;
    <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
    <stable> <accessor> <paramaccessor> protected def privateParent: scala.meta.Tree = Impl.this.privateParent;
    @transient <paramaccessor> private[this] var privateTokens: scala.meta.tokens.Tokens = _;
    <accessor> <paramaccessor> protected def privateTokens: scala.meta.tokens.Tokens = Impl.this.privateTokens;
    <accessor> <paramaccessor> protected def privateTokens_=(x$1: scala.meta.tokens.Tokens): Unit = Impl.this.privateTokens = x$1;
    <paramaccessor> private[this] val privateEnv: scala.meta.internal.semantic.Environment = _;
    <stable> <accessor> <paramaccessor> protected def privateEnv: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
    <paramaccessor> private[this] val privateTyping: scala.meta.internal.semantic.Typing = _;
    <stable> <accessor> <paramaccessor> protected def privateTyping: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
    <paramaccessor> private[this] val privateExpansion: scala.meta.internal.semantic.Expansion = _;
    <stable> <accessor> <paramaccessor> protected def privateExpansion: scala.meta.internal.semantic.Expansion = Impl.this.privateExpansion;
    <paramaccessor> private[this] var _cond: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _cond: scala.meta.internal.ast.Term = Impl.this._cond;
    <accessor> <paramaccessor> def _cond_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._cond = x$1;
    <paramaccessor> private[this] var _thenp: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _thenp: scala.meta.internal.ast.Term = Impl.this._thenp;
    <accessor> <paramaccessor> def _thenp_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._thenp = x$1;
    <paramaccessor> private[this] var _elsep: scala.meta.internal.ast.Term = _;
    <accessor> <paramaccessor> def _elsep: scala.meta.internal.ast.Term = Impl.this._elsep;
    <accessor> <paramaccessor> def _elsep_=(x$1: scala.meta.internal.ast.Term): Unit = Impl.this._elsep = x$1;
    def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.internal.ast.Term.If, privateParent: scala.meta.Tree, privateTokens: scala.meta.tokens.Tokens, privateEnv: scala.meta.internal.semantic.Environment, privateTyping: scala.meta.internal.semantic.Typing, privateExpansion: scala.meta.internal.semantic.Expansion)(_cond: scala.meta.internal.ast.Term, _thenp: scala.meta.internal.ast.Term, _elsep: scala.meta.internal.ast.Term): scala.meta.internal.ast.Term.If.Impl = {
      Impl.super.<init>();
      ()
    };
    def parent: Option[scala.meta.Tree] = if (Impl.this.privateParent.!=(null))
      scala.Some.apply[scala.meta.Tree](Impl.this.privateParent)
    else
      scala.None;
    def children: scala.collection.immutable.Seq[scala.meta.Tree] = (scala.collection.immutable.List.apply[scala.meta.internal.ast.Term](this.cond, this.thenp, this.elsep): scala.collection.immutable.Seq[scala.meta.Tree]);
    def tokens: scala.meta.tokens.Tokens = {
      Impl.this.privateTokens_=(Impl.this.privateTokens match {
        case null => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.None)
        case (prototype: scala.meta.Tree)scala.meta.internal.tokens.TransformedTokens((proto @ _)) => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
        case (other @ _) => other
      });
      Impl.this.privateTokens
    };
    private[meta] def env: scala.meta.internal.semantic.Environment = if (Impl.this.privateEnv.!=(null))
      Impl.this.privateEnv
    else
      scala.meta.internal.semantic.Environment.Zero;
    protected def privateDenot: scala.meta.internal.semantic.Denotation = null;
    private[meta] def typing: scala.meta.internal.semantic.Typing = if (Impl.this.privateTyping.!=(null))
      Impl.this.privateTyping
    else
      scala.meta.internal.semantic.Typing.Zero;
    private[meta] def expansion: scala.meta.internal.semantic.Expansion = if (Impl.this.privateExpansion.!=(null))
      Impl.this.privateExpansion
    else
      scala.meta.internal.semantic.Expansion.Zero;
    def cond: scala.meta.internal.ast.Term = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            val copyCond$macro$203: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$43: scala.meta.internal.ast.Term = this.privatePrototype.cond;
              <artifact> val x$1986: scala.meta.internal.ast.Term = this.privatePrototype.cond;
              <artifact> val x$1987: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$1988: meta.internal.flags.Flags = qual$43.privateCopy$default$1;
              <artifact> val x$1989: scala.meta.tokens.Tokens = qual$43.privateCopy$default$4;
              <artifact> val x$1990: scala.meta.internal.semantic.Environment = qual$43.privateCopy$default$5;
              <artifact> val x$1991: scala.meta.internal.semantic.Denotation = qual$43.privateCopy$default$6;
              <artifact> val x$1992: scala.meta.internal.semantic.Typing = qual$43.privateCopy$default$7;
              <artifact> val x$1993: scala.meta.internal.semantic.Expansion = qual$43.privateCopy$default$8;
              qual$43.privateCopy(x$1988, x$1986, x$1987, x$1989, x$1990, x$1991, x$1992, x$1993)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyCond$macro$203).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyCond$macro$203
          })
        }
      else
        (): Unit);
      this._cond
    };
    def thenp: scala.meta.internal.ast.Term = {
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            val copyThenp$macro$204: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$44: scala.meta.internal.ast.Term = this.privatePrototype.thenp;
              <artifact> val x$1994: scala.meta.internal.ast.Term = this.privatePrototype.thenp;
              <artifact> val x$1995: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$1996: meta.internal.flags.Flags = qual$44.privateCopy$default$1;
              <artifact> val x$1997: scala.meta.tokens.Tokens = qual$44.privateCopy$default$4;
              <artifact> val x$1998: scala.meta.internal.semantic.Environment = qual$44.privateCopy$default$5;
              <artifact> val x$1999: scala.meta.internal.semantic.Denotation = qual$44.privateCopy$default$6;
              <artifact> val x$2000: scala.meta.internal.semantic.Typing = qual$44.privateCopy$default$7;
              <artifact> val x$2001: scala.meta.internal.semantic.Expansion = qual$44.privateCopy$default$8;
              qual$44.privateCopy(x$1996, x$1994, x$1995, x$1997, x$1998, x$1999, x$2000, x$2001)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyThenp$macro$204).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyThenp$macro$204
          })
        }
      else
        (): Unit);
      this._thenp
    };
    def elsep: scala.meta.internal.ast.Term = {
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            val copyElsep$macro$205: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$45: scala.meta.internal.ast.Term = this.privatePrototype.elsep;
              <artifact> val x$2002: scala.meta.internal.ast.Term = this.privatePrototype.elsep;
              <artifact> val x$2003: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$2004: meta.internal.flags.Flags = qual$45.privateCopy$default$1;
              <artifact> val x$2005: scala.meta.tokens.Tokens = qual$45.privateCopy$default$4;
              <artifact> val x$2006: scala.meta.internal.semantic.Environment = qual$45.privateCopy$default$5;
              <artifact> val x$2007: scala.meta.internal.semantic.Denotation = qual$45.privateCopy$default$6;
              <artifact> val x$2008: scala.meta.internal.semantic.Typing = qual$45.privateCopy$default$7;
              <artifact> val x$2009: scala.meta.internal.semantic.Expansion = qual$45.privateCopy$default$8;
              qual$45.privateCopy(x$2004, x$2002, x$2003, x$2005, x$2006, x$2007, x$2008, x$2009)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyElsep$macro$205).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyElsep$macro$205
          })
        }
      else
        (): Unit);
      this._elsep
    };
    private[meta] def privateCopy(flags: meta.internal.flags.Flags = Impl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.privateParent, tokens: scala.meta.tokens.Tokens = Impl.this.privateTokens, env: scala.meta.internal.semantic.Environment = Impl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.privateTyping, expansion: scala.meta.internal.semantic.Expansion = Impl.this.privateExpansion): Impl.this.ThisType = new If.this.Impl(flags, prototype.asInstanceOf[Impl.this.ThisType], parent, tokens, env, typing, expansion)((null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term), (null: scala.meta.internal.ast.Term));
    override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = Impl.this.privateFlags;
    override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
    override <synthetic> def privateCopy$default$3: scala.meta.Tree = Impl.this.privateParent;
    override <synthetic> def privateCopy$default$4: scala.meta.tokens.Tokens = Impl.this.privateTokens;
    override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
    override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot;
    override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
    override <synthetic> def privateCopy$default$8: scala.meta.internal.semantic.Expansion = Impl.this.privateExpansion;
    protected def writeReplace(): AnyRef = {
      (if (this._cond.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.cond");
          this._cond_=({
            val copyCond$macro$206: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$46: scala.meta.internal.ast.Term = this.privatePrototype.cond;
              <artifact> val x$2010: scala.meta.internal.ast.Term = this.privatePrototype.cond;
              <artifact> val x$2011: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$2012: meta.internal.flags.Flags = qual$46.privateCopy$default$1;
              <artifact> val x$2013: scala.meta.tokens.Tokens = qual$46.privateCopy$default$4;
              <artifact> val x$2014: scala.meta.internal.semantic.Environment = qual$46.privateCopy$default$5;
              <artifact> val x$2015: scala.meta.internal.semantic.Denotation = qual$46.privateCopy$default$6;
              <artifact> val x$2016: scala.meta.internal.semantic.Typing = qual$46.privateCopy$default$7;
              <artifact> val x$2017: scala.meta.internal.semantic.Expansion = qual$46.privateCopy$default$8;
              qual$46.privateCopy(x$2012, x$2010, x$2011, x$2013, x$2014, x$2015, x$2016, x$2017)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyCond$macro$206).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyCond$macro$206
          })
        }
      else
        (): Unit);
      (if (this._thenp.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.thenp");
          this._thenp_=({
            val copyThenp$macro$207: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$47: scala.meta.internal.ast.Term = this.privatePrototype.thenp;
              <artifact> val x$2018: scala.meta.internal.ast.Term = this.privatePrototype.thenp;
              <artifact> val x$2019: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$2020: meta.internal.flags.Flags = qual$47.privateCopy$default$1;
              <artifact> val x$2021: scala.meta.tokens.Tokens = qual$47.privateCopy$default$4;
              <artifact> val x$2022: scala.meta.internal.semantic.Environment = qual$47.privateCopy$default$5;
              <artifact> val x$2023: scala.meta.internal.semantic.Denotation = qual$47.privateCopy$default$6;
              <artifact> val x$2024: scala.meta.internal.semantic.Typing = qual$47.privateCopy$default$7;
              <artifact> val x$2025: scala.meta.internal.semantic.Expansion = qual$47.privateCopy$default$8;
              qual$47.privateCopy(x$2020, x$2018, x$2019, x$2021, x$2022, x$2023, x$2024, x$2025)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyThenp$macro$207).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyThenp$macro$207
          })
        }
      else
        (): Unit);
      (if (this._elsep.==(null))
        {
          scala.Predef.require(this.privatePrototype.!=(null), "internal error when initializing Impl.elsep");
          this._elsep_=({
            val copyElsep$macro$208: scala.meta.internal.ast.Term#ThisType = {
              <artifact> val qual$48: scala.meta.internal.ast.Term = this.privatePrototype.elsep;
              <artifact> val x$2026: scala.meta.internal.ast.Term = this.privatePrototype.elsep;
              <artifact> val x$2027: scala.meta.internal.ast.Term.If.Impl = this;
              <artifact> val x$2028: meta.internal.flags.Flags = qual$48.privateCopy$default$1;
              <artifact> val x$2029: scala.meta.tokens.Tokens = qual$48.privateCopy$default$4;
              <artifact> val x$2030: scala.meta.internal.semantic.Environment = qual$48.privateCopy$default$5;
              <artifact> val x$2031: scala.meta.internal.semantic.Denotation = qual$48.privateCopy$default$6;
              <artifact> val x$2032: scala.meta.internal.semantic.Typing = qual$48.privateCopy$default$7;
              <artifact> val x$2033: scala.meta.internal.semantic.Expansion = qual$48.privateCopy$default$8;
              qual$48.privateCopy(x$2028, x$2026, x$2027, x$2029, x$2030, x$2031, x$2032, x$2033)
            };
            if (meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If](this.privatePrototype).isTypechecked.!=(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked))
              meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term#ThisType](copyElsep$macro$208).withTypechecked(meta.this.Tree.XtensionTypecheckableTree[scala.meta.internal.ast.Term.If.Impl](this).isTypechecked)
            else
              copyElsep$macro$208
          })
        }
      else
        (): Unit);
      this
    }
  };
  @org.scalameta.ast.internal.astClass @org.scalameta.adt.Internal.leafClass abstract private[meta] trait Quasi extends AnyRef with scala.meta.internal.ast.Term.If with scala.meta.internal.ast.Quasi with scala.meta.internal.ast.Term.Quasi with Product {
    @org.scalameta.ast.internal.astField def rank: Int;
    @org.scalameta.ast.internal.astField def tree: Any;
    override type ThisType <: scala.meta.internal.ast.Term.If.Quasi
  };
  @@<?> @@<?> private[meta] object Quasi extends scala.AnyRef with Serializable {
    def <init>(): scala.meta.internal.ast.Term.If.Quasi.type = {
      Quasi.super.<init>();
      ()
    };
    def privateTag: Int = 89;
    def apply(rank: Int, tree: Any): scala.meta.internal.ast.Term.If.Quasi = {
      def internal(rank: Int, tree: Any): scala.meta.internal.ast.Term.If.Quasi = {
        ((): Unit);
        ();
        ();
        ();
        ();
        val node: scala.meta.internal.ast.Term.If.Quasi.Impl = new Quasi.this.Impl(scala.meta.internal.flags.`package`.ZERO, null, null, null)((rank: Int), (tree: Any));
        ((): Unit);
        ((): Unit);
        node
      };
      internal(rank, tree)
    };
    @inline final def unapply(x: scala.meta.internal.ast.Term.If.Quasi): Option[(Int, Any)] = if (x.==(null))
      scala.None
    else
      scala.Some.apply[(Int, Any)](scala.Tuple2.apply[Int, Any](x.rank, x.tree));
    import scala.language.experimental.{macros=>prettyPlease};
    import scala.language.implicitConversions;
    @scala.reflect.macros.internal.macroImpl(`macro`("macroEngine" = "v7.0 (implemented in Scala 2.11.0-M8)", "isBundle" = true, "isBlackbox" = true, "className" = "org.scalameta.ast.internal$Macros", "methodName" = "interfaceToApi", "signature" = List(List(-3), List(0, 1)))[scala.meta.internal.ast.Term.If.Quasi, scala.meta.internal.ast.Term.If.Quasi.Api]) implicit <macro> def interfaceToApi(interface: scala.meta.internal.ast.Term.If.Quasi): scala.meta.internal.ast.Term.If.Quasi.Api = new org.scalameta.ast.internal.Macros(null).interfaceToApi[scala.meta.internal.ast.Term.If.Quasi, scala.meta.internal.ast.Term.If.Quasi.Api];
    abstract trait Api extends AnyRef with scala.meta.internal.ast.Term.If.Quasi {
      def /*Api*/$init$(): Unit = {
        ()
      };
      override private[meta] def env: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def privateEnv: scala.meta.internal.semantic.Environment = null;
      override protected def privateDenot: scala.meta.internal.semantic.Denotation = null;
      override private[meta] def typing: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def privateTyping: scala.meta.internal.semantic.Typing = null;
      override private[meta] def expansion: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override protected def privateExpansion: scala.meta.internal.semantic.Expansion = null;
      override def cond: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def thenp: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override def elsep: Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override private[meta] def withEnv(env: scala.meta.internal.semantic.Environment): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override private[meta] def withAttrs(typingLike: meta.internal.semantic.TypingLike): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      override private[meta] def withExpansion(expansionLike: meta.internal.semantic.ExpansionLike): Nothing = throw new scala.`package`.UnsupportedOperationException(if (this.rank.==(0))
        "unsupported unquoting position"
      else
        "unsupported splicing position");
      def pt: Class[_] = org.scalameta.runtime.`package`.arrayClass(classOf[scala.meta.internal.ast.Term$$If], this.rank);
      def tokens: scala.meta.tokens.Tokens;
      def copy(rank: Int = this.rank, tree: Any = this.tree): scala.meta.internal.ast.Term.If.Quasi = If.this.Quasi.apply(rank, tree).withTokens(scala.meta.internal.tokens.TransformedTokens.apply(this));
      <synthetic> def copy$default$1: Int = this.rank;
      <synthetic> def copy$default$2: Any = this.tree;
      protected def privateWithFlags(flags: meta.internal.flags.Flags): scala.meta.internal.ast.Term.If.Quasi = {
        this.privateCopy(flags, this.privateCopy$default$2, this.privateCopy$default$3, this.privateCopy$default$4, this.privateCopy$default$5, this.privateCopy$default$6, this.privateCopy$default$7, this.privateCopy$default$8)
      };
      def withTokens(tokens: scala.meta.tokens.Tokens): scala.meta.internal.ast.Term.If.Quasi = {
        <artifact> val x$2034: scala.meta.tokens.Tokens = tokens;
        <artifact> val x$2035: meta.internal.flags.Flags = this.privateCopy$default$1;
        <artifact> val x$2036: scala.meta.Tree = this.privateCopy$default$2;
        <artifact> val x$2037: scala.meta.Tree = this.privateCopy$default$3;
        <artifact> val x$2038: scala.meta.internal.semantic.Environment = this.privateCopy$default$5;
        <artifact> val x$2039: scala.meta.internal.semantic.Denotation = this.privateCopy$default$6;
        <artifact> val x$2040: scala.meta.internal.semantic.Typing = this.privateCopy$default$7;
        <artifact> val x$2041: scala.meta.internal.semantic.Expansion = this.privateCopy$default$8;
        this.privateCopy(x$2035, x$2036, x$2037, x$2034, x$2038, x$2039, x$2040, x$2041)
      };
      override type ThisType = scala.meta.internal.ast.Term.If.Quasi;
      override def privateTag: Int = If.this.Quasi.privateTag;
      override def productPrefix: String = ("Term.If.Quasi": String);
      override def productArity: Int = 2;
      override def productElement(n: Int): Any = n match {
        case 0 => this.rank
        case 1 => this.tree
        case _ => throw new scala.`package`.IndexOutOfBoundsException(n.toString())
      };
      override def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Nothing](this)
    };
    @SerialVersionUID(value = 1L) final private[Quasi] class Impl extends AnyRef with scala.meta.internal.ast.Term.If.Quasi.Api {
      <paramaccessor> private[this] val privateFlags: meta.internal.flags.Flags = _;
      <stable> <accessor> <paramaccessor> protected def privateFlags: meta.internal.flags.Flags = Impl.this.privateFlags;
      @transient <paramaccessor> private[this] val privatePrototype: scala.meta.internal.ast.Term.If.Quasi = _;
      <stable> <accessor> <paramaccessor> protected def privatePrototype: scala.meta.internal.ast.Term.If.Quasi = Impl.this.privatePrototype;
      <paramaccessor> private[this] val privateParent: scala.meta.Tree = _;
      <stable> <accessor> <paramaccessor> protected def privateParent: scala.meta.Tree = Impl.this.privateParent;
      @transient <paramaccessor> private[this] var privateTokens: scala.meta.tokens.Tokens = _;
      <accessor> <paramaccessor> protected def privateTokens: scala.meta.tokens.Tokens = Impl.this.privateTokens;
      <accessor> <paramaccessor> protected def privateTokens_=(x$1: scala.meta.tokens.Tokens): Unit = Impl.this.privateTokens = x$1;
      <paramaccessor> private[this] var _rank: Int = _;
      <accessor> <paramaccessor> def _rank: Int = Impl.this._rank;
      <accessor> <paramaccessor> def _rank_=(x$1: Int): Unit = Impl.this._rank = x$1;
      <paramaccessor> private[this] var _tree: Any = _;
      <accessor> <paramaccessor> def _tree: Any = Impl.this._tree;
      <accessor> <paramaccessor> def _tree_=(x$1: Any): Unit = Impl.this._tree = x$1;
      def <init>(privateFlags: meta.internal.flags.Flags, privatePrototype: scala.meta.internal.ast.Term.If.Quasi, privateParent: scala.meta.Tree, privateTokens: scala.meta.tokens.Tokens)(_rank: Int, _tree: Any): scala.meta.internal.ast.Term.If.Quasi.Impl = {
        Impl.super.<init>();
        ()
      };
      def parent: Option[scala.meta.Tree] = if (Impl.this.privateParent.!=(null))
        scala.Some.apply[scala.meta.Tree](Impl.this.privateParent)
      else
        scala.None;
      def children: scala.collection.immutable.Seq[scala.meta.Tree] = (immutable.this.Nil: scala.collection.immutable.Seq[scala.meta.Tree]);
      def tokens: scala.meta.tokens.Tokens = {
        Impl.this.privateTokens_=(Impl.this.privateTokens match {
          case null => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.None)
          case (prototype: scala.meta.Tree)scala.meta.internal.tokens.TransformedTokens((proto @ _)) => scala.meta.internal.prettyprinters.inferTokens.apply(this, scala.Some.apply[scala.meta.Tree](proto))
          case (other @ _) => other
        });
        Impl.this.privateTokens
      };
      def rank: Int = {
        ((): Unit);
        this._rank
      };
      def tree: Any = {
        ((): Unit);
        this._tree
      };
      private[meta] def privateCopy(flags: meta.internal.flags.Flags = Impl.this.privateFlags, prototype: scala.meta.Tree = this, parent: scala.meta.Tree = Impl.this.privateParent, tokens: scala.meta.tokens.Tokens = Impl.this.privateTokens, env: scala.meta.internal.semantic.Environment = Impl.this.privateEnv, denot: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot, typing: scala.meta.internal.semantic.Typing = Impl.this.privateTyping, expansion: scala.meta.internal.semantic.Expansion = Impl.this.privateExpansion): Impl.this.ThisType = new Quasi.this.Impl(flags, prototype.asInstanceOf[Impl.this.ThisType], parent, tokens)((this._rank: Int), (this._tree: Any));
      override <synthetic> def privateCopy$default$1: meta.internal.flags.Flags = Impl.this.privateFlags;
      override <synthetic> def privateCopy$default$2: scala.meta.Tree = this;
      override <synthetic> def privateCopy$default$3: scala.meta.Tree = Impl.this.privateParent;
      override <synthetic> def privateCopy$default$4: scala.meta.tokens.Tokens = Impl.this.privateTokens;
      override <synthetic> def privateCopy$default$5: scala.meta.internal.semantic.Environment = Impl.this.privateEnv;
      override <synthetic> def privateCopy$default$6: scala.meta.internal.semantic.Denotation = Impl.this.privateDenot;
      override <synthetic> def privateCopy$default$7: scala.meta.internal.semantic.Typing = Impl.this.privateTyping;
      override <synthetic> def privateCopy$default$8: scala.meta.internal.semantic.Expansion = Impl.this.privateExpansion;
      protected def writeReplace(): AnyRef = {
        ((): Unit);
        ((): Unit);
        this
      };
      def become[T <: scala.meta.internal.ast.Quasi](implicit ev: org.scalameta.ast.AstMetadata[T]): T = this match {
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)) => ev.quasi(0, tree).withTokens(this.tokens).asInstanceOf[T]
        case If.this.Quasi.unapply(<unapply-selector>) <unapply> (1, (nested @ If.this.Quasi.unapply(<unapply-selector>) <unapply> (0, (tree @ _)))) => ev.quasi(1, nested.become[T](ev)).withTokens(this.tokens).asInstanceOf[T]
        case _ => throw new scala.`package`.Exception("complex ellipses are not supported yet")
      }
    };
    <synthetic> private def readResolve(): Object = If.this.Quasi
  };
  <synthetic> private def readResolve(): Object = Term.this.If
};
```
