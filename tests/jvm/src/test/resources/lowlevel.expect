semanticdb/integration/src/main/scala/example/Empty.scala
---------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Empty.scala
Text => non-empty
Language => Scala212
Symbols => 2 entries
Occurrences => 1 entries

Symbols:
_empty_.Empty# => class Empty.{+1 decls}
  extends AnyRef
_empty_.Empty#`<init>`()V. => primaryctor <init>: (): Empty
  Empty => _empty_.Empty#

Occurrences:
[0:6..0:11): Empty <= _empty_.Empty#

semanticdb/integration/src/main/scala/example/Example.scala
-----------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Example.scala
Text => non-empty
Language => Scala212
Symbols => 18 entries
Occurrences => 22 entries
Diagnostics => 1 entries
Synthetics => 1 entries

Symbols:
_root_.example. => package example
_root_.example.Example. => final object Example
_root_.example.Example.main([Ljava/lang/String;)V. => def main: (args: Array[String]): Unit
  args => _root_.example.Example.main([Ljava/lang/String;)V.(args)
  Unit => _root_.scala.Unit#
_root_.example.Example.main([Ljava/lang/String;)V.(args) => param args: Array[String]
  Array => _root_.scala.Array#
  String => _root_.scala.Predef.String#
_root_.example.Example.x. => val x: : ClassTag[Int]
  ClassTag => _root_.scala.reflect.ClassTag#
  Int => _root_.scala.Int#
_root_.scala. => package scala
_root_.scala.Array# => final class Array.{+6 decls}
  extends AnyRef
  extends Serializable
  extends Cloneable
_root_.scala.Int# => abstract final class Int.{+111 decls}
  extends AnyVal
_root_.scala.Predef.String# => type String: String
  String => _root_.java.lang.String#
_root_.scala.Predef.println(Ljava/lang/Object;)V. => def println: (x: <?>): Unit
  x => _root_.scala.Predef.println(Ljava/lang/Object;)V.(x)
  Unit => _root_.scala.Unit#
_root_.scala.Unit# => abstract final class Unit.{+2 decls}
  extends AnyVal
_root_.scala.collection. => package collection
_root_.scala.collection.mutable. => package mutable
_root_.scala.collection.mutable.Stack# => @deprecated @deprecated class Stack.{+20 decls}
  extends AbstractSeq[Stack#[A]
  extends Seq[Stack#[A]
  extends SeqLike[Stack#[A, Stack[Stack#[A]]
  extends GenericTraversableTemplate[Stack#[A, Stack]
  extends Cloneable[Stack[Stack#[A]]
  extends Serializable
_root_.scala.collection.mutable.Stack#`<init>`()V. => secondaryctor <init>: (): Stack[Stack#[A]
  Stack => _root_.scala.collection.mutable.Stack#
  Stack#[A => _root_.scala.collection.mutable.Stack#[A]
_root_.scala.concurrent. => package concurrent
_root_.scala.reflect. => package reflect
_root_.scala.reflect.package.classTag(Lscala/reflect/ClassTag;)Lscala/reflect/ClassTag;. => def classTag: [T: <?>] => (ctag: <?>): ClassTag[T]
  T => _root_.scala.reflect.package.classTag(Lscala/reflect/ClassTag;)Lscala/reflect/ClassTag;.[T]
  ctag => _root_.scala.reflect.package.classTag(Lscala/reflect/ClassTag;)Lscala/reflect/ClassTag;.(ctag)
  ClassTag => _root_.scala.reflect.ClassTag#

Occurrences:
[0:8..0:15): example <= _root_.example.
[2:7..2:12): scala => _root_.scala.
[2:13..2:23): concurrent => _root_.scala.concurrent.
[2:24..2:30): Future => _root_.scala.concurrent.Future#;_root_.scala.concurrent.Future.
[4:7..4:14): Example <= _root_.example.Example.
[5:6..5:11): scala => _root_.scala.
[5:12..5:22): collection => _root_.scala.collection.
[5:23..5:30): mutable => _root_.scala.collection.mutable.
[5:31..5:36): Stack => _root_.scala.collection.mutable.Stack#
[5:37..5:40): Int => _root_.scala.Int#
[5:41..5:41):  => _root_.scala.collection.mutable.Stack#`<init>`()V.
[6:6..6:10): main <= _root_.example.Example.main([Ljava/lang/String;)V.
[6:11..6:15): args <= _root_.example.Example.main([Ljava/lang/String;)V.(args)
[6:17..6:22): Array => _root_.scala.Array#
[6:23..6:29): String => _root_.scala.Predef.String#
[6:33..6:37): Unit => _root_.scala.Unit#
[7:4..7:11): println => _root_.scala.Predef.println(Ljava/lang/Object;)V.
[9:6..9:7): x <= _root_.example.Example.x.
[9:10..9:15): scala => _root_.scala.
[9:16..9:23): reflect => _root_.scala.reflect.
[9:24..9:32): classTag => _root_.scala.reflect.package.classTag(Lscala/reflect/ClassTag;)Lscala/reflect/ClassTag;.
[9:33..9:36): Int => _root_.scala.Int#

Diagnostics:
[2:24..2:30)[warning] Unused import

Synthetics:
[9:37..9:37):  => *(((ClassTag.Int): ClassTag[Int]))
  [0:0..0:1): * => _star_.
  [0:13..0:16): Int => _root_.scala.reflect.ClassTag.Int.
  [0:19..0:27): ClassTag => _root_.scala.reflect.ClassTag#
  [0:28..0:31): Int => _root_.scala.Int#
semanticdb/integration/src/main/scala/example/Example.scala
-----------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Example.scala
Text => empty
Language => Scala212
Diagnostics => 1 entries

Diagnostics:
[5:6..5:41)[warning] class Stack in package mutable is deprecated (since 2.12.0): Stack is an inelegant and potentially poorly-performing wrapper around List. Use a List assigned to a var instead.

semanticdb/integration/src/main/scala/example/Flags.scala
---------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Flags.scala
Text => non-empty
Language => Scala212
Symbols => 41 entries
Occurrences => 56 entries

Symbols:
_root_.flags. => package flags
_root_.flags.p.package. => package object package
_root_.flags.p.package.AA# => class AA.{+7 decls}
  extends AnyRef
_root_.flags.p.package.AA#(x) => param x: Int
  Int => _root_.scala.Int#
_root_.flags.p.package.AA#(y) => valparam param y: : Int
  Int => _root_.scala.Int#
_root_.flags.p.package.AA#(z) => varparam param z_=: (x$1: <?>): Unit
  x$1 => _root_.flags.p.package.AA#`z_=`(I)V.(x$1)
  Unit => _root_.scala.Unit#
_root_.flags.p.package.AA#`<init>`(III)V. => primaryctor <init>: (x: <?>, y: <?>, z: <?>): AA
  x => _root_.flags.p.package.AA#`<init>`(III)V.(x)
  y => _root_.flags.p.package.AA#`<init>`(III)V.(y)
  z => _root_.flags.p.package.AA#`<init>`(III)V.(z)
  AA => _root_.flags.p.package.AA#
_root_.flags.p.package.C# => abstract class C.{+6 decls}
  extends AnyRef
_root_.flags.p.package.C#(x) => param x: T
  T => _root_.flags.p.package.C#[T]
_root_.flags.p.package.C#(y) => param y: U
  U => _root_.flags.p.package.C#[U]
_root_.flags.p.package.C#(z) => param z: V
  V => _root_.flags.p.package.C#[V]
_root_.flags.p.package.C#[T] => covariant typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.flags.p.package.C#[U] => contravariant typeparam U: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.flags.p.package.C#[V] => typeparam V: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.flags.p.package.C#`<init>`()V. => secondaryctor <init>: (): C[T, U, V]
  C => _root_.flags.p.package.C#
  T => _root_.flags.p.package.C#[T]
  U => _root_.flags.p.package.C#[U]
  V => _root_.flags.p.package.C#[V]
_root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V. => primaryctor <init>: (x: <?>, y: <?>, z: <?>): C[T, U, V]
  x => _root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V.(x)
  y => _root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V.(y)
  z => _root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V.(z)
  C => _root_.flags.p.package.C#
  T => _root_.flags.p.package.C#[T]
  U => _root_.flags.p.package.C#[U]
  V => _root_.flags.p.package.C#[V]
_root_.flags.p.package.C#w()I. => abstract def w: : Int
  Int => _root_.scala.Int#
_root_.flags.p.package.S# => class S.{+1 decls}
  extends AnyRef
_root_.flags.p.package.S#[T] => @specialized typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.flags.p.package.S#`<init>`()V. => primaryctor <init>: (): S[T]
  S => _root_.flags.p.package.S#
  T => _root_.flags.p.package.S#[T]
_root_.flags.p.package.T# => type T: Int
  Int => _root_.scala.Int#
_root_.flags.p.package.U# => abstract type U: >: Nothing <: Int
  Nothing => _root_.scala.Nothing#
  Int => _root_.scala.Int#
_root_.flags.p.package.V# => abstract type V: >: Int <: Any
  Int => _root_.scala.Int#
  Any => _root_.scala.Any#
_root_.flags.p.package.X. => final case object X
_root_.flags.p.package.Y# => final class Y.{+1 decls}
  extends AnyRef
_root_.flags.p.package.Y#`<init>`()V. => primaryctor <init>: (): Y
  Y => _root_.flags.p.package.Y#
_root_.flags.p.package.Z# => sealed trait Z
  extends AnyRef
_root_.flags.p.package.m()Lscala/Nothing;. => macro m: [TT >: Nothing <: Any] => : Nothing
  TT => _root_.flags.p.package.m()Lscala/Nothing;.[TT]
  Nothing => _root_.scala.Nothing#
_root_.flags.p.package.m()Lscala/Nothing;.[TT] => typeparam TT: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.flags.p.package.x. => private lazy val x: : Int
  Int => _root_.scala.Int#
_root_.flags.p.package.y. => protected var y_=: (x$1: <?>): Unit
  x$1 => _root_.flags.p.package.`y_=`(I)V.(x$1)
  Unit => _root_.scala.Unit#
_root_.flags.p.package.z(I)I. => def z: (pp: Int): Int
  pp => _root_.flags.p.package.z(I)I.(pp)
  Int => _root_.scala.Int#
_root_.flags.p.package.z(I)I.(pp) => param pp: Int
  Int => _root_.scala.Int#
_root_.scala. => package scala
_root_.scala.Int# => abstract final class Int.{+111 decls}
  extends AnyVal
_root_.scala.Predef.`???`()Lscala/Nothing;. => def ???: : Nothing
  Nothing => _root_.scala.Nothing#
_root_.scala.language. => final object language
_root_.scala.language.experimental. => final object experimental
_root_.scala.language.experimental.macros. => implicit lazy val macros: : macros
  macros => _root_.scala.languageFeature.experimental.macros#
_root_.scala.specialized# => class specialized.{+4 decls}
  extends Annotation
  extends StaticAnnotation
_root_.scala.specialized#`<init>`()V. => secondaryctor <init>: (): specialized
  specialized => _root_.scala.specialized#

Occurrences:
[0:8..0:13): flags <= _root_.flags.
[2:7..2:12): scala => _root_.scala.
[2:13..2:21): language => _root_.scala.language.
[2:22..2:34): experimental => _root_.scala.language.experimental.
[2:35..2:41): macros => _root_.scala.language.experimental.macros.
[4:15..4:16): p <= _root_.flags.p.package.
[5:19..5:20): x <= _root_.flags.p.package.x.
[6:25..6:26): y <= _root_.flags.p.package.y.
[6:28..6:31): Int => _root_.scala.Int#
[7:6..7:7): z <= _root_.flags.p.package.z(I)I.
[7:8..7:10): pp <= _root_.flags.p.package.z(I)I.(pp)
[7:12..7:15): Int => _root_.scala.Int#
[8:6..8:7): m <= _root_.flags.p.package.m()Lscala/Nothing;.
[8:8..8:10): TT <= _root_.flags.p.package.m()Lscala/Nothing;.[TT]
[8:20..8:23): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[9:17..9:18): C <= _root_.flags.p.package.C#
[9:20..9:21): T <= _root_.flags.p.package.C#[T]
[9:24..9:25): U <= _root_.flags.p.package.C#[U]
[9:27..9:28): V <= _root_.flags.p.package.C#[V]
[9:29..9:29):  <= _root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V.
[9:30..9:31): x <= _root_.flags.p.package.C#(x)
[9:33..9:34): T => _root_.flags.p.package.C#[T]
[9:36..9:37): y <= _root_.flags.p.package.C#(y)
[9:39..9:40): U => _root_.flags.p.package.C#[U]
[9:42..9:43): z <= _root_.flags.p.package.C#(z)
[9:45..9:46): V => _root_.flags.p.package.C#[V]
[10:8..10:12): this <= _root_.flags.p.package.C#`<init>`()V.
[10:21..10:21):  => _root_.flags.p.package.C#`<init>`(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V.
[10:22..10:25): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[10:27..10:30): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[10:32..10:35): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[11:8..11:9): w <= _root_.flags.p.package.C#w()I.
[11:11..11:14): Int => _root_.scala.Int#
[13:7..13:8): T <= _root_.flags.p.package.T#
[13:11..13:14): Int => _root_.scala.Int#
[14:7..14:8): U <= _root_.flags.p.package.U#
[14:12..14:15): Int => _root_.scala.Int#
[15:7..15:8): V <= _root_.flags.p.package.V#
[15:12..15:15): Int => _root_.scala.Int#
[16:14..16:15): X <= _root_.flags.p.package.X.
[17:14..17:15): Y <= _root_.flags.p.package.Y#
[17:15..17:15):  <= _root_.flags.p.package.Y#`<init>`()V.
[18:15..18:16): Z <= _root_.flags.p.package.Z#
[19:8..19:10): AA <= _root_.flags.p.package.AA#
[19:10..19:10):  <= _root_.flags.p.package.AA#`<init>`(III)V.
[19:11..19:12): x <= _root_.flags.p.package.AA#(x)
[19:14..19:17): Int => _root_.scala.Int#
[19:23..19:24): y <= _root_.flags.p.package.AA#(y)
[19:26..19:29): Int => _root_.scala.Int#
[19:35..19:36): z <= _root_.flags.p.package.AA#(z)
[19:38..19:41): Int => _root_.scala.Int#
[20:8..20:9): S <= _root_.flags.p.package.S#
[20:11..20:22): specialized => _root_.scala.specialized#
[20:23..20:23):  => _root_.scala.specialized#`<init>`()V.
[20:23..20:24): T <= _root_.flags.p.package.S#[T]
[21:0..21:0):  <= _root_.flags.p.package.S#`<init>`()V.

semanticdb/integration/src/main/scala/example/Overrides.scala
-------------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Overrides.scala
Text => non-empty
Language => Scala212
Symbols => 8 entries
Occurrences => 10 entries

Symbols:
_root_.example. => package example
_root_.example.A# => trait A.{+1 decls}
  extends AnyRef
_root_.example.A#foo()I. => abstract def foo: : Int
  Int => _root_.scala.Int#
_root_.example.B# => class B.{+2 decls}
  extends AnyRef
  extends A
_root_.example.B#`<init>`()V. => primaryctor <init>: (): B
  B => _root_.example.B#
_root_.example.B#foo()I. => def foo: : Int
  Int => _root_.scala.Int#
  overrides _root_.example.A#foo()I.
_root_.java.lang.Object#`<init>`()V. => primaryctor <init>: (): Object
  Object => _root_.java.lang.Object#
_root_.scala.Int# => abstract final class Int.{+111 decls}
  extends AnyVal

Occurrences:
[0:8..0:15): example <= _root_.example.
[2:6..2:7): A <= _root_.example.A#
[2:14..2:17): foo <= _root_.example.A#foo()I.
[2:19..2:22): Int => _root_.scala.Int#
[3:6..3:7): B <= _root_.example.B#
[3:7..3:7):  <= _root_.example.B#`<init>`()V.
[3:18..3:19): A => _root_.example.A#
[3:20..3:20):  => _root_.java.lang.Object#`<init>`()V.
[3:26..3:29): foo <= _root_.example.B#foo()I.
[3:31..3:34): Int => _root_.scala.Int#

semanticdb/integration/src/main/scala/example/Synthetic.scala
-------------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Synthetic.scala
Text => non-empty
Language => Scala212
Symbols => 11 entries
Occurrences => 11 entries
Synthetics => 6 entries

Symbols:
_root_.example. => package example
_root_.example.Synthetic# => class Synthetic.{+1 decls}
  extends AnyRef
_root_.example.Synthetic#`<init>`()V. => primaryctor <init>: (): Synthetic
  Synthetic => _root_.example.Synthetic#
_root_.scala.Array. => final object Array
_root_.scala.Array.empty(Lscala/reflect/ClassTag;)Ljava/lang/Object;. => def empty: [T: <?>] => (evidence$1: <?>): Array[T]
  T => _root_.scala.Array.empty(Lscala/reflect/ClassTag;)Ljava/lang/Object;.[T]
  evidence$1 => _root_.scala.Array.empty(Lscala/reflect/ClassTag;)Ljava/lang/Object;.(evidence$1)
  Array => _root_.scala.Array#
_root_.scala.Int# => abstract final class Int.{+111 decls}
  extends AnyVal
_root_.scala.Int#`+`(I)I. => abstract def +: (x: <?>): Int
  x => _root_.scala.Int#`+`(I)I.(x)
  Int => _root_.scala.Int#
_root_.scala.collection.TraversableLike#headOption()Lscala/Option;. => def headOption: : Option[TraversableLike#[A]
  Option => _root_.scala.Option#
  TraversableLike#[A => _root_.scala.collection.TraversableLike#[A]
_root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;. => final def map: [B: <?>, That: <?>] => (f: <?>)(bf: <?>): That
  B => _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[B]
  That => _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.[That]
  f => _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.(f)
  bf => _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.(bf)
_root_.scala.collection.immutable.List. => final object List
_root_.scala.collection.immutable.StringLike#stripPrefix(Ljava/lang/String;)Ljava/lang/String;. => def stripPrefix: (prefix: <?>): String
  prefix => _root_.scala.collection.immutable.StringLike#stripPrefix(Ljava/lang/String;)Ljava/lang/String;.(prefix)
  String => _root_.java.lang.String#

Occurrences:
[0:8..0:15): example <= _root_.example.
[2:6..2:15): Synthetic <= _root_.example.Synthetic#
[2:16..2:16):  <= _root_.example.Synthetic#`<init>`()V.
[3:2..3:6): List => _root_.scala.collection.immutable.List.
[3:10..3:13): map => _root_.scala.collection.immutable.List#map(Lscala/Function1;Lscala/collection/generic/CanBuildFrom;)Ljava/lang/Object;.
[3:16..3:17): + => _root_.scala.Int#`+`(I)I.
[4:2..4:7): Array => _root_.scala.Array.
[4:8..4:13): empty => _root_.scala.Array.empty(Lscala/reflect/ClassTag;)Ljava/lang/Object;.
[4:14..4:17): Int => _root_.scala.Int#
[4:19..4:29): headOption => _root_.scala.collection.TraversableLike#headOption()Lscala/Option;.
[5:9..5:20): stripPrefix => _root_.scala.collection.immutable.StringLike#stripPrefix(Ljava/lang/String;)Ljava/lang/String;.

Synthetics:
[3:6..3:6):  => *.apply[Int]
  [0:0..0:1): * => _star_.
  [0:2..0:7): apply => _root_.scala.collection.immutable.List.apply(Lscala/collection/Seq;)Lscala/collection/immutable/List;.
  [0:8..0:11): Int => _root_.scala.Int#
[3:13..3:13):  => *[Int, List[Int]]
  [0:0..0:1): * => _star_.
  [0:2..0:5): Int => _root_.scala.Int#
  [0:7..0:11): List => _root_.scala.collection.immutable.List#
  [0:12..0:15): Int => _root_.scala.Int#
[3:20..3:20):  => *(scala.collection.immutable.List.canBuildFrom[Int])
  [0:0..0:1): * => _star_.
  [0:34..0:46): canBuildFrom => _root_.scala.collection.immutable.List.canBuildFrom()Lscala/collection/generic/CanBuildFrom;.
  [0:47..0:50): Int => _root_.scala.Int#
[4:2..4:18): Array.empty[Int] => scala.Predef.intArrayOps(*)
  [0:13..0:24): intArrayOps => _root_.scala.Predef.intArrayOps([I)[I.
  [0:25..0:26): * => _star_.
[4:18..4:18):  => *(((ClassTag.Int): ClassTag[Int]))
  [0:0..0:1): * => _star_.
  [0:13..0:16): Int => _root_.scala.reflect.ClassTag.Int.
  [0:19..0:27): ClassTag => _root_.scala.reflect.ClassTag#
  [0:28..0:31): Int => _root_.scala.Int#
[5:2..5:8): "fooo" => scala.Predef.augmentString(*)
  [0:13..0:26): augmentString => _root_.scala.Predef.augmentString(Ljava/lang/String;)Ljava/lang/String;.
  [0:27..0:28): * => _star_.

semanticdb/integration/src/main/scala/example/Types.scala
---------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/Types.scala
Text => non-empty
Language => Scala212
Symbols => 123 entries
Occurrences => 224 entries

Symbols:
_root_.java. => package java
_root_.java.nio. => package nio
_root_.java.nio.file. => package file
_root_.java.nio.file.LinkOption. => final object LinkOption
_root_.java.nio.file.LinkOption.NOFOLLOW_LINKS. => final val NOFOLLOW_LINKS: NOFOLLOW_LINKS.type
  NOFOLLOW_LINKS => _root_.java.nio.file.LinkOption.NOFOLLOW_LINKS.
_root_.scala. => package scala
_root_.scala.Int# => abstract final class Int.{+111 decls}
  extends AnyVal
_root_.scala.Option# => @SerialVersionUID abstract sealed class Option.{+25 decls}
  extends AnyRef
  extends Product
  extends Serializable
_root_.scala.Predef.`???`()Lscala/Nothing;. => def ???: : Nothing
  Nothing => _root_.scala.Nothing#
_root_.scala.Predef.classOf()Ljava/lang/Class;. => def classOf: [T: <?>] => : Class[T]
  T => _root_.scala.Predef.classOf()Ljava/lang/Class;.[T]
  Class => _root_.scala.Predef.Class#
_root_.scala.annotation. => package annotation
_root_.scala.annotation.StaticAnnotation# => trait StaticAnnotation
  extends Annotation
_root_.scala.collection.SeqLike#length()I. => abstract def length: : Int
  Int => _root_.scala.Int#
_root_.scala.language. => final object language
_root_.scala.language.existentials. => implicit lazy val existentials: : existentials
  existentials => _root_.scala.languageFeature.existentials#
_root_.scala.language.higherKinds. => implicit lazy val higherKinds: : higherKinds
  higherKinds => _root_.scala.languageFeature.higherKinds#
_root_.scala.package.List# => val List: : List.type
  List => _root_.scala.collection.immutable.List.
_root_.types. => package types
_root_.types.B# => class B.{+1 decls}
  extends AnyRef
_root_.types.B#`<init>`()V. => primaryctor <init>: (): B
  B => _root_.types.B#
_root_.types.C# => class C.{+1 decls}
  extends AnyRef
_root_.types.C#`<init>`()V. => primaryctor <init>: (): C
  C => _root_.types.C#
_root_.types.P# => class P.{+5 decls}
  extends AnyRef
_root_.types.P#C# => class C.{+1 decls}
  extends AnyRef
_root_.types.P#C#`<init>`()V. => primaryctor <init>: (): P.this.C
  P => _root_.types.P#
  C => _root_.types.P#C#
_root_.types.P#X# => class X.{+1 decls}
  extends AnyRef
_root_.types.P#X#`<init>`()V. => primaryctor <init>: (): P.this.X
  P => _root_.types.P#
  X => _root_.types.P#X#
_root_.types.P#`<init>`()V. => primaryctor <init>: (): P
  P => _root_.types.P#
_root_.types.P#x. => val x: : P.this.X
  P => _root_.types.P#
  X => _root_.types.P#X#
_root_.types.T# => class T.{+5 decls}
  extends AnyRef
_root_.types.T#C# => class C.{+1 decls}
  extends AnyRef
_root_.types.T#C#`<init>`()V. => primaryctor <init>: (): T.this.C
  T => _root_.types.T#
  C => _root_.types.T#C#
_root_.types.T#X# => class X.{+1 decls}
  extends AnyRef
_root_.types.T#X#`<init>`()V. => primaryctor <init>: (): T.this.X
  T => _root_.types.T#
  X => _root_.types.T#X#
_root_.types.T#`<init>`()V. => primaryctor <init>: (): T
  T => _root_.types.T#
_root_.types.T#x. => val x: : T.this.X
  T => _root_.types.T#
  X => _root_.types.T#X#
_root_.types.Test. => final object Test
_root_.types.Test.C# => class C.{+48 decls}
  extends M
_root_.types.Test.C#$anon#L# => type L: [T >: Nothing <: Any] => List[T]
  T => _root_.types.Test.C#$anon#L#[T]
  List => _root_.scala.package.List#
_root_.types.Test.C#$anon#L#[T] => typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#$anon#k()I. => abstract def k: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#ByNameType. => final object ByNameType
_root_.types.Test.C#ByNameType.m1(Lscala/Function0;)I. => def m1: (x: => Int): Int
  x => _root_.types.Test.C#ByNameType.m1(Lscala/Function0;)I.(x)
  Int => _root_.scala.Int#
_root_.types.Test.C#ByNameType.m1(Lscala/Function0;)I.(x) => param x: => Int
  Int => _root_.scala.Int#
_root_.types.Test.C#ClassInfoType1. => final object ClassInfoType1
_root_.types.Test.C#ClassInfoType2# => class ClassInfoType2.{+2 decls}
  extends B
_root_.types.Test.C#ClassInfoType2#`<init>`()V. => primaryctor <init>: (): C.this.ClassInfoType2
  C => _root_.types.Test.C#
  ClassInfoType2 => _root_.types.Test.C#ClassInfoType2#
_root_.types.Test.C#ClassInfoType2#x()I. => def x: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#ClassInfoType3# => trait ClassInfoType3
  extends AnyRef
_root_.types.Test.C#ClassInfoType3#[T] => typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#MethodType. => final object MethodType
_root_.types.Test.C#MethodType.m3()I. => def m3: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#MethodType.m4()I. => def m4: (): Int
  Int => _root_.scala.Int#
_root_.types.Test.C#MethodType.m5(I)I. => def m5: (x: Int): Int
  x => _root_.types.Test.C#MethodType.m5(I)I.(x)
  Int => _root_.scala.Int#
_root_.types.Test.C#MethodType.m5(I)I.(x) => param x: Int
  Int => _root_.scala.Int#
_root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;. => def m6: [T >: Nothing <: Any] => (x: T): T
  T => _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T]
  x => _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.(x)
_root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.(x) => param x: T
  T => _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T]
_root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T] => typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#MethodType.x1()I. => def x1: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#MethodType.x2()I. => def x2: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#RepeatedType# => case class RepeatedType.{+12 decls}
  extends AnyRef
  extends Product
  extends Serializable
_root_.types.Test.C#RepeatedType#(s) => valparam param s: : String*
  String => _root_.scala.Predef.String#
_root_.types.Test.C#RepeatedType#`<init>`(Lscala/collection/Seq;)V. => primaryctor <init>: (s: <?>): C.this.RepeatedType
  s => _root_.types.Test.C#RepeatedType#`<init>`(Lscala/collection/Seq;)V.(s)
  C => _root_.types.Test.C#
  RepeatedType => _root_.types.Test.C#RepeatedType#
_root_.types.Test.C#RepeatedType#m1(Lscala/collection/Seq;)I. => def m1: (x: Int*): Int
  x => _root_.types.Test.C#RepeatedType#m1(Lscala/collection/Seq;)I.(x)
  Int => _root_.scala.Int#
_root_.types.Test.C#RepeatedType#m1(Lscala/collection/Seq;)I.(x) => param x: Int*
  Int => _root_.scala.Int#
_root_.types.Test.C#TypeType. => final object TypeType
_root_.types.Test.C#TypeType.T1# => abstract type T1: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#TypeType.T4# => type T4: C
  C => _root_.types.Test.C#
_root_.types.Test.C#TypeType.T5# => type T5: [U >: Nothing <: Any] => U
  U => _root_.types.Test.C#TypeType.T5#[U]
_root_.types.Test.C#TypeType.T5#[U] => typeparam U: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#TypeType.m2()Lscala/Nothing;. => def m2: [T2 >: C <: C] => : Nothing
  T2 => _root_.types.Test.C#TypeType.m2()Lscala/Nothing;.[T2]
  Nothing => _root_.scala.Nothing#
_root_.types.Test.C#TypeType.m2()Lscala/Nothing;.[T2] => typeparam T2: >: C <: C
  C => _root_.types.Test.C#
_root_.types.Test.C#TypeType.m3()Lscala/Nothing;. => def m3: [M3 [M3][_: <?>] => >: Nothing <: Any] => : Nothing
  M3 => _root_.types.Test.C#TypeType.m3()Lscala/Nothing;.[M3]
  Nothing => _root_.scala.Nothing#
_root_.types.Test.C#TypeType.m3()Lscala/Nothing;.[M3] => typeparam M3: [M3][_: <?>] => >: Nothing <: Any
  M3][_ => _root_.types.Test.C#TypeType.m3()Lscala/Nothing;.[M3][_]
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#`<init>`()V. => primaryctor <init>: (): C
  C => _root_.types.Test.C#
_root_.types.Test.C#annType1. => val annType1: : T @ann[Int]
  T => _root_.types.T#
  ann => _root_.types.ann#
  Int => _root_.scala.Int#
_root_.types.Test.C#annType2. => val annType2: : T @ann1 @ann2
  T => _root_.types.T#
  ann1 => _root_.types.ann1#
  ann2 => _root_.types.ann2#
_root_.types.Test.C#compoundType1. => val compoundType1: : AnyRef { <?> }
  AnyRef => _root_.scala.AnyRef#
  k => _root_.types.Test.C#$anon#k()I.
_root_.types.Test.C#compoundType2. => val compoundType2: : M with N
  M => _root_.types.Test.M#
  N => _root_.types.Test.N#
_root_.types.Test.C#compoundType3. => val compoundType3: : M with N { <?> }
  M => _root_.types.Test.M#
  N => _root_.types.Test.N#
  k => _root_.types.Test.C#$anon#k()I.
_root_.types.Test.C#existentialType1. => val existentialType1: : T forSome { type T >: Nothing <: Any }
  T => _root_.types.Test.C#existentialType1.T#
_root_.types.Test.C#existentialType1.T# => abstract type T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#p. => val p: : P
  P => _root_.types.P#
_root_.types.Test.C#singleType1. => val singleType1: : C.this.x.type
  C => _root_.types.Test.C#
  x => _root_.types.Test.C#x.
_root_.types.Test.C#singleType2. => val singleType2: : C.this.p.x.type
  C => _root_.types.Test.C#
  p => _root_.types.Test.C#p.
  x => _root_.types.P#x.
_root_.types.Test.C#superType1. => val superType1: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#superType2. => val superType2: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#superType3. => val superType3: : Int
  Int => _root_.scala.Int#
_root_.types.Test.C#thisType1. => val thisType1: : C.this.type
  C => _root_.types.Test.C#
_root_.types.Test.C#thisType2. => val thisType2: : C.this.type
  C => _root_.types.Test.C#
_root_.types.Test.C#typeLambda1()Lscala/Nothing;. => def typeLambda1: [M [M][_: <?>] => >: Nothing <: Any] => : Nothing
  M => _root_.types.Test.C#typeLambda1()Lscala/Nothing;.[M]
  Nothing => _root_.scala.Nothing#
_root_.types.Test.C#typeLambda1()Lscala/Nothing;.[M] => typeparam M: [M][_: <?>] => >: Nothing <: Any
  M][_ => _root_.types.Test.C#typeLambda1()Lscala/Nothing;.[M][_]
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.Test.C#typeRef1. => val typeRef1: : C
  C => _root_.types.Test.C#
_root_.types.Test.C#typeRef2. => val typeRef2: : C.this.p.C
  C => _root_.types.Test.C#
  p => _root_.types.Test.C#p.
  C => _root_.types.P#C#
_root_.types.Test.C#typeRef3. => val typeRef3: : T#C
  T => _root_.types.T#
  C => _root_.types.T#C#
_root_.types.Test.C#typeRef4. => val typeRef4: : List[Int]
  List => _root_.scala.package.List#
  Int => _root_.scala.Int#
_root_.types.Test.C#x. => val x: : C.this.p.X
  C => _root_.types.Test.C#
  p => _root_.types.Test.C#p.
  X => _root_.types.P#X#
_root_.types.Test.Literal. => final object Literal
_root_.types.Test.Literal.bool. => final val bool: : true
_root_.types.Test.Literal.char. => final val char: : 'a'
_root_.types.Test.Literal.clazzOf. => final val clazzOf: : Class[Option[Int]]
  Class => _root_.java.lang.Class#
  Option => _root_.scala.Option#
  Int => _root_.scala.Int#
_root_.types.Test.Literal.double. => final val double: : 2.0
_root_.types.Test.Literal.float. => final val float: : 1.0f
_root_.types.Test.Literal.int. => final val int: : 1
_root_.types.Test.Literal.javaEnum. => final val javaEnum: : NOFOLLOW_LINKS.type
  NOFOLLOW_LINKS => _root_.java.nio.file.LinkOption.NOFOLLOW_LINKS.
_root_.types.Test.Literal.long. => final val long: : 1L
_root_.types.Test.Literal.nil. => final val nil: : null
_root_.types.Test.Literal.string. => final val string: : "a"
_root_.types.Test.Literal.unit. => final val unit: : Unit
  Unit => _root_.scala.Unit#
_root_.types.Test.M# => class M.{+2 decls}
  extends AnyRef
_root_.types.Test.M#`<init>`()V. => primaryctor <init>: (): M
  M => _root_.types.Test.M#
_root_.types.Test.M#m()I. => def m: : Int
  Int => _root_.scala.Int#
_root_.types.Test.N# => class N.{+2 decls}
  extends AnyRef
_root_.types.Test.N#`<init>`()V. => primaryctor <init>: (): N
  N => _root_.types.Test.N#
_root_.types.Test.N#n()I. => def n: : Int
  Int => _root_.scala.Int#
_root_.types.ann# => class ann.{+2 decls}
  extends Annotation
  extends StaticAnnotation
_root_.types.ann#(x) => param x: T
  T => _root_.types.ann#[T]
_root_.types.ann#[T] => typeparam T: >: Nothing <: Any
  Nothing => _root_.scala.Nothing#
  Any => _root_.scala.Any#
_root_.types.ann#`<init>`(Ljava/lang/Object;)V. => primaryctor <init>: (x: <?>): ann[T]
  x => _root_.types.ann#`<init>`(Ljava/lang/Object;)V.(x)
  ann => _root_.types.ann#
  T => _root_.types.ann#[T]
_root_.types.ann1# => class ann1.{+1 decls}
  extends Annotation
  extends StaticAnnotation
_root_.types.ann1#`<init>`()V. => primaryctor <init>: (): ann1
  ann1 => _root_.types.ann1#
_root_.types.ann2# => class ann2.{+1 decls}
  extends Annotation
  extends StaticAnnotation
_root_.types.ann2#`<init>`()V. => primaryctor <init>: (): ann2
  ann2 => _root_.types.ann2#

Occurrences:
[0:8..0:13): types <= _root_.types.
[2:7..2:12): scala => _root_.scala.
[2:13..2:21): language => _root_.scala.language.
[2:22..2:34): existentials => _root_.scala.language.existentials.
[3:7..3:12): scala => _root_.scala.
[3:13..3:21): language => _root_.scala.language.
[3:22..3:33): higherKinds => _root_.scala.language.higherKinds.
[5:6..5:9): ann <= _root_.types.ann#
[5:10..5:11): T <= _root_.types.ann#[T]
[5:12..5:12):  <= _root_.types.ann#`<init>`(Ljava/lang/Object;)V.
[5:13..5:14): x <= _root_.types.ann#(x)
[5:16..5:17): T => _root_.types.ann#[T]
[5:27..5:32): scala => _root_.scala.
[5:33..5:43): annotation => _root_.scala.annotation.
[5:44..5:60): StaticAnnotation => _root_.scala.annotation.StaticAnnotation#
[6:6..6:10): ann1 <= _root_.types.ann1#
[6:11..6:11):  <= _root_.types.ann1#`<init>`()V.
[6:19..6:24): scala => _root_.scala.
[6:25..6:35): annotation => _root_.scala.annotation.
[6:36..6:52): StaticAnnotation => _root_.scala.annotation.StaticAnnotation#
[7:6..7:10): ann2 <= _root_.types.ann2#
[7:11..7:11):  <= _root_.types.ann2#`<init>`()V.
[7:19..7:24): scala => _root_.scala.
[7:25..7:35): annotation => _root_.scala.annotation.
[7:36..7:52): StaticAnnotation => _root_.scala.annotation.StaticAnnotation#
[9:6..9:7): B <= _root_.types.B#
[11:6..11:7): C <= _root_.types.C#
[13:6..13:7): P <= _root_.types.P#
[13:8..13:8):  <= _root_.types.P#`<init>`()V.
[14:8..14:9): C <= _root_.types.P#C#
[14:9..14:9):  <= _root_.types.P#C#`<init>`()V.
[15:8..15:9): X <= _root_.types.P#X#
[15:9..15:9):  <= _root_.types.P#X#`<init>`()V.
[16:6..16:7): x <= _root_.types.P#x.
[16:14..16:15): X => _root_.types.P#X#
[17:0..17:0):  => _root_.types.P#X#`<init>`()V.
[19:6..19:7): T <= _root_.types.T#
[19:8..19:8):  <= _root_.types.T#`<init>`()V.
[20:8..20:9): C <= _root_.types.T#C#
[20:9..20:9):  <= _root_.types.T#C#`<init>`()V.
[21:8..21:9): X <= _root_.types.T#X#
[21:9..21:9):  <= _root_.types.T#X#`<init>`()V.
[22:6..22:7): x <= _root_.types.T#x.
[22:14..22:15): X => _root_.types.T#X#
[23:0..23:0):  => _root_.types.T#X#`<init>`()V.
[25:7..25:11): Test <= _root_.types.Test.
[26:8..26:9): M <= _root_.types.Test.M#
[26:10..26:10):  <= _root_.types.Test.M#`<init>`()V.
[27:8..27:9): m <= _root_.types.Test.M#m()I.
[27:11..27:14): Int => _root_.scala.Int#
[27:17..27:20): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[30:8..30:9): N <= _root_.types.Test.N#
[30:10..30:10):  <= _root_.types.Test.N#`<init>`()V.
[31:8..31:9): n <= _root_.types.Test.N#n()I.
[31:11..31:14): Int => _root_.scala.Int#
[31:17..31:20): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[34:8..34:9): C <= _root_.types.Test.C#
[34:10..34:10):  <= _root_.types.Test.C#`<init>`()V.
[34:18..34:19): M => _root_.types.Test.M#
[34:20..34:20):  => _root_.types.Test.M#`<init>`()V.
[35:8..35:9): p <= _root_.types.Test.C#p.
[35:16..35:17): P => _root_.types.P#
[35:17..35:17):  => _root_.types.P#`<init>`()V.
[36:8..36:9): x <= _root_.types.Test.C#x.
[36:12..36:13): p => _root_.types.Test.C#p.
[36:14..36:15): x => _root_.types.P#x.
[38:8..38:16): typeRef1 <= _root_.types.Test.C#typeRef1.
[38:18..38:19): C => _root_.types.Test.C#
[38:22..38:25): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[39:8..39:16): typeRef2 <= _root_.types.Test.C#typeRef2.
[39:18..39:19): p => _root_.types.Test.C#p.
[39:20..39:21): C => _root_.types.P#C#
[39:24..39:27): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[40:8..40:16): typeRef3 <= _root_.types.Test.C#typeRef3.
[40:18..40:19): T => _root_.types.T#
[40:20..40:21): C => _root_.types.T#C#
[40:24..40:27): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[41:8..41:16): typeRef4 <= _root_.types.Test.C#typeRef4.
[41:18..41:22): List => _root_.scala.package.List#
[41:23..41:26): Int => _root_.scala.Int#
[41:30..41:33): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[43:8..43:19): singleType1 <= _root_.types.Test.C#singleType1.
[43:21..43:22): x => _root_.types.Test.C#x.
[43:30..43:33): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[44:8..44:19): singleType2 <= _root_.types.Test.C#singleType2.
[44:21..44:22): p => _root_.types.Test.C#p.
[44:23..44:24): x => _root_.types.P#x.
[44:32..44:35): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[46:8..46:17): thisType1 <= _root_.types.Test.C#thisType1.
[46:31..46:34): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[47:8..47:17): thisType2 <= _root_.types.Test.C#thisType2.
[47:19..47:20): C => _root_.types.Test.C#
[47:33..47:36): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[49:8..49:18): superType1 <= _root_.types.Test.C#superType1.
[49:27..49:28): m => _root_.types.Test.M#m()I.
[50:8..50:18): superType2 <= _root_.types.Test.C#superType2.
[50:27..50:28): M => _root_.types.Test.C#
[50:30..50:31): m => _root_.types.Test.M#m()I.
[51:8..51:18): superType3 <= _root_.types.Test.C#superType3.
[51:21..51:22): C => _root_.types.Test.C#
[51:29..51:30): M => _root_.types.Test.C#
[51:32..51:33): m => _root_.types.Test.M#m()I.
[53:8..53:21): compoundType1 <= _root_.types.Test.C#compoundType1.
[53:29..53:30): k <= _root_.types.Test.C#$anon#k()I.
[53:32..53:35): Int => _root_.scala.Int#
[53:40..53:43): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[54:8..54:21): compoundType2 <= _root_.types.Test.C#compoundType2.
[54:23..54:24): M => _root_.types.Test.M#
[54:30..54:31): N => _root_.types.Test.N#
[54:34..54:37): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[55:8..55:21): compoundType3 <= _root_.types.Test.C#compoundType3.
[55:23..55:24): M => _root_.types.Test.M#
[55:30..55:31): N => _root_.types.Test.N#
[55:38..55:39): k <= _root_.types.Test.C#$anon#k()I.
[55:41..55:44): Int => _root_.scala.Int#
[55:49..55:52): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[57:8..57:16): annType1 <= _root_.types.Test.C#annType1.
[57:18..57:19): T => _root_.types.T#
[57:21..57:24): ann => _root_.types.ann#
[57:24..57:24):  => _root_.types.ann#`<init>`(Ljava/lang/Object;)V.
[57:31..57:34): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[58:8..58:16): annType2 <= _root_.types.Test.C#annType2.
[58:18..58:19): T => _root_.types.T#
[58:21..58:25): ann1 => _root_.types.ann1#
[58:26..58:26):  => _root_.types.ann1#`<init>`()V.
[58:27..58:31): ann2 => _root_.types.ann2#
[58:32..58:32):  => _root_.types.ann2#`<init>`()V.
[58:34..58:37): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[60:8..60:24): existentialType1 <= _root_.types.Test.C#existentialType1.
[60:26..60:27): T => _root_.types.Test.C#existentialType1.T#
[60:43..60:44): T <= _root_.types.Test.C#existentialType1.T#
[60:49..60:52): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[62:8..62:19): typeLambda1 <= _root_.types.Test.C#typeLambda1()Lscala/Nothing;.
[62:20..62:21): M <= _root_.types.Test.C#typeLambda1()Lscala/Nothing;.[M]
[62:28..62:31): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[63:4..63:15): typeLambda1 => _root_.types.Test.C#typeLambda1()Lscala/Nothing;.
[63:24..63:25): L <= _root_.types.Test.C#$anon#L#
[63:26..63:27): T <= _root_.types.Test.C#$anon#L#[T]
[63:31..63:35): List => _root_.scala.package.List#
[63:36..63:37): T => _root_.types.Test.C#$anon#L#[T]
[63:42..63:43): L => _root_.types.Test.C#$anon#L#
[65:11..65:25): ClassInfoType1 <= _root_.types.Test.C#ClassInfoType1.
[66:10..66:24): ClassInfoType2 <= _root_.types.Test.C#ClassInfoType2#
[66:25..66:25):  <= _root_.types.Test.C#ClassInfoType2#`<init>`()V.
[66:33..66:34): B => _root_.types.B#
[66:35..66:35):  => _root_.types.B#`<init>`()V.
[66:41..66:42): x <= _root_.types.Test.C#ClassInfoType2#x()I.
[67:10..67:24): ClassInfoType3 <= _root_.types.Test.C#ClassInfoType3#
[67:25..67:26): T <= _root_.types.Test.C#ClassInfoType3#[T]
[69:11..69:21): MethodType <= _root_.types.Test.C#MethodType.
[70:10..70:12): x1 <= _root_.types.Test.C#MethodType.x1()I.
[70:14..70:17): Int => _root_.scala.Int#
[70:20..70:23): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[71:10..71:12): x2 <= _root_.types.Test.C#MethodType.x2()I.
[71:14..71:17): Int => _root_.scala.Int#
[71:20..71:23): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[72:10..72:12): m3 <= _root_.types.Test.C#MethodType.m3()I.
[72:14..72:17): Int => _root_.scala.Int#
[72:20..72:23): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[73:10..73:12): m4 <= _root_.types.Test.C#MethodType.m4()I.
[73:16..73:19): Int => _root_.scala.Int#
[73:22..73:25): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[74:10..74:12): m5 <= _root_.types.Test.C#MethodType.m5(I)I.
[74:13..74:14): x <= _root_.types.Test.C#MethodType.m5(I)I.(x)
[74:16..74:19): Int => _root_.scala.Int#
[74:22..74:25): Int => _root_.scala.Int#
[74:28..74:31): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[75:10..75:12): m6 <= _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.
[75:13..75:14): T <= _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T]
[75:16..75:17): x <= _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.(x)
[75:19..75:20): T => _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T]
[75:23..75:24): T => _root_.types.Test.C#MethodType.m6(Ljava/lang/Object;)Ljava/lang/Object;.[T]
[75:27..75:30): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[78:11..78:21): ByNameType <= _root_.types.Test.C#ByNameType.
[79:10..79:12): m1 <= _root_.types.Test.C#ByNameType.m1(Lscala/Function0;)I.
[79:13..79:14): x <= _root_.types.Test.C#ByNameType.m1(Lscala/Function0;)I.(x)
[79:19..79:22): Int => _root_.scala.Int#
[79:25..79:28): Int => _root_.scala.Int#
[79:31..79:34): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[82:15..82:27): RepeatedType <= _root_.types.Test.C#RepeatedType#
[82:27..82:27):  <= _root_.types.Test.C#RepeatedType#`<init>`(Lscala/collection/Seq;)V.
[82:28..82:29): s <= _root_.types.Test.C#RepeatedType#(s)
[82:31..82:37): String => _root_.scala.`<repeated>`#
[83:10..83:12): m1 <= _root_.types.Test.C#RepeatedType#m1(Lscala/collection/Seq;)I.
[83:13..83:14): x <= _root_.types.Test.C#RepeatedType#m1(Lscala/collection/Seq;)I.(x)
[83:16..83:19): Int => _root_.scala.`<repeated>`#
[83:23..83:26): Int => _root_.scala.Int#
[83:29..83:30): s => _root_.types.Test.C#RepeatedType#(s)
[83:31..83:37): length => _root_.scala.collection.SeqLike#length()I.
[86:11..86:19): TypeType <= _root_.types.Test.C#TypeType.
[87:11..87:13): T1 <= _root_.types.Test.C#TypeType.T1#
[88:10..88:12): m2 <= _root_.types.Test.C#TypeType.m2()Lscala/Nothing;.
[88:13..88:15): T2 <= _root_.types.Test.C#TypeType.m2()Lscala/Nothing;.[T2]
[88:19..88:20): C => _root_.types.Test.C#
[88:24..88:25): C => _root_.types.Test.C#
[88:29..88:32): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[89:10..89:12): m3 <= _root_.types.Test.C#TypeType.m3()Lscala/Nothing;.
[89:13..89:15): M3 <= _root_.types.Test.C#TypeType.m3()Lscala/Nothing;.[M3]
[89:22..89:25): ??? => _root_.scala.Predef.`???`()Lscala/Nothing;.
[90:11..90:13): T4 <= _root_.types.Test.C#TypeType.T4#
[90:16..90:17): C => _root_.types.Test.C#
[91:11..91:13): T5 <= _root_.types.Test.C#TypeType.T5#
[91:14..91:15): U <= _root_.types.Test.C#TypeType.T5#[U]
[91:19..91:20): U => _root_.types.Test.C#TypeType.T5#[U]
[95:9..95:16): Literal <= _root_.types.Test.Literal.
[96:14..96:17): int <= _root_.types.Test.Literal.int.
[97:14..97:18): long <= _root_.types.Test.Literal.long.
[98:14..98:19): float <= _root_.types.Test.Literal.float.
[99:14..99:20): double <= _root_.types.Test.Literal.double.
[100:14..100:17): nil <= _root_.types.Test.Literal.nil.
[101:14..101:18): char <= _root_.types.Test.Literal.char.
[102:14..102:20): string <= _root_.types.Test.Literal.string.
[103:14..103:18): bool <= _root_.types.Test.Literal.bool.
[104:14..104:18): unit <= _root_.types.Test.Literal.unit.
[105:14..105:22): javaEnum <= _root_.types.Test.Literal.javaEnum.
[105:25..105:29): java => _root_.java.
[105:30..105:33): nio => _root_.java.nio.
[105:34..105:38): file => _root_.java.nio.file.
[105:39..105:49): LinkOption => _root_.java.nio.file.LinkOption.
[105:50..105:64): NOFOLLOW_LINKS => _root_.java.nio.file.LinkOption.NOFOLLOW_LINKS.
[106:14..106:21): clazzOf <= _root_.types.Test.Literal.clazzOf.
[106:24..106:31): classOf => _root_.scala.Predef.classOf()Ljava/lang/Class;.
[106:32..106:38): Option => _root_.scala.Option#
[106:39..106:42): Int => _root_.scala.Int#

semanticdb/integration/src/main/scala/example/local-file.scala
--------------------------------------------------------------

Summary:
Schema => SemanticDB v3
Uri => semanticdb/integration/src/main/scala/example/local-file.scala
Text => non-empty
Language => Scala212
Symbols => 6 entries
Occurrences => 7 entries
Synthetics => 1 entries

Symbols:
_root_.example. => package example
_root_.example.`local-file`# => class local-file.{+1 decls}
  extends AnyRef
_root_.example.`local-file`#`<init>`()V. => primaryctor <init>: (): local-file
  local-file => _root_.example.`local-file`#
_root_.scala.Int#`+`(I)I. => abstract def +: (x: <?>): Int
  x => _root_.scala.Int#`+`(I)I.(x)
  Int => _root_.scala.Int#
_root_.scala.Predef.locally(Ljava/lang/Object;)Ljava/lang/Object;. => @inline def locally: [T: <?>] => (x: <?>): T
  T => _root_.scala.Predef.locally(Ljava/lang/Object;)Ljava/lang/Object;.[T]
  x => _root_.scala.Predef.locally(Ljava/lang/Object;)Ljava/lang/Object;.(x)
local0 => val local: Int
  Int => _root_.scala.Int#

Occurrences:
[0:8..0:15): example <= _root_.example.
[2:6..2:18): `local-file` <= _root_.example.`local-file`#
[2:19..2:19):  <= _root_.example.`local-file`#`<init>`()V.
[3:2..3:9): locally => _root_.scala.Predef.locally(Ljava/lang/Object;)Ljava/lang/Object;.
[4:8..4:13): local <= local0
[5:4..5:9): local => local0
[5:10..5:11): + => _root_.scala.Int#`+`(I)I.

Synthetics:
[3:9..3:9):  => *[Int]
  [0:0..0:1): * => _star_.
  [0:2..0:5): Int => _root_.scala.Int#
